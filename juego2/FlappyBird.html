<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flappy Bird Standalone</title>
    <style>
        /* Estilos generales del cuerpo */
        body {
            margin: 0;
            height: 100vh; /* Asegura que el body ocupe toda la altura */
            display: flex; /* Centra el juego vertical y horizontalmente */
            align-items: center;
            justify-content: center;
            background-color: #f0f0f0; /* Un color de fondo suave */
            font-family: sans-serif;
            overflow: hidden; /* Evita barras de scroll */
            /* Evitar selección de texto en móviles */
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10+ */
            user-select: none;
        }

        /* Contenedor principal del juego */
        #flappy-game {
            position: relative; /* Necesario para posicionar elementos internos absolutamente */
            width: 100vw; /* Ocupa todo el ancho de la ventana */
            height: 100vh; /* Ocupa toda la altura de la ventana */
            max-width: 600px; /* Ancho máximo para pantallas grandes */
            max-height: 800px; /* Altura máxima para pantallas grandes */
            background-color: #87CEEB; /* Color cielo */
            overflow: hidden; /* Oculta lo que salga del área */
            border: 2px solid #333; /* Borde opcional */
            box-shadow: 0 5px 15px rgba(0,0,0,0.2); /* Sombra para darle profundidad */
            cursor: pointer; /* Indica que se puede hacer clic */
        }

        /* Área donde se mueven los elementos del juego */
        #flappy-game-area {
            position: relative;
            width: 100%;
            height: 100%;
        }

        /* Estilo del pájaro */
        #flappy-bird {
            position: absolute;
            left: 20%; /* Posición inicial horizontal */
            top: 50%; /* Posición inicial vertical */
            transform: translate(-50%, -50%); /* Centrado exacto */
            font-size: 2rem; /* Tamaño del pájaro (emoji) */
            user-select: none; /* Evita seleccionar el texto del pájaro */
            z-index: 10; /* Asegura que esté por encima de los obstáculos */
            transition: transform 0.1s ease-out; /* Suaviza la rotación al caer/subir */
        }

        /* Estilo de los obstáculos (tuberías) */
        .obstacle-flappy {
            position: absolute;
            width: 60px; /* Ancho de las tuberías */
            background-color: #2E8B57; /* Color verde oscuro */
            border: 2px solid #000; /* Borde negro */
            z-index: 5; /* Detrás del pájaro */
        }

        /* Superposición de inicio/fin */
        #flappy-start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6); /* Fondo semitransparente */
            display: flex;
            flex-direction: column; /* Apila los mensajes */
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            color: white;
            text-align: center;
            z-index: 100; /* Por encima de todo */
            cursor: pointer;
            line-height: 1.6; /* Mejora el espaciado entre líneas */
        }

        /* Estilo para el mensaje de puntuación final */
        #score-message {
            margin-top: 20px;
            font-size: 1.2rem;
            font-weight: bold;
        }

        /* Ocultar mensaje de puntuación inicialmente */
        #score-message:empty {
            display: none;
        }

        /* Estilo para el contador de puntuación en vivo */
        #live-score {
            position: absolute;
            top: 15px;
            right: 15px;
            color: white;
            font-size: 1.8rem;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7); /* Sombra para mejorar legibilidad */
            z-index: 50; /* Encima del juego, debajo del overlay de inicio/fin */
            user-select: none;
        }

    </style>
</head>
<body>
    <div id="flappy-game">
        <div id="flappy-game-area">
            <div id="flappy-bird">(*_*)</div>
            </div>
        <div id="live-score">Puntuación: 0</div>
        <div id="flappy-start-overlay">
            <div id="start-message">Haz clic para empezar</div>
            <div id="score-message"></div> </div>
    </div>

    <script>
        // --- Variables Globales del Juego ---
        let flappyGameRunning = false; // Indica si el juego está en curso
        let flappyBird; // Elemento HTML del pájaro
        let flappyGameArea; // Elemento HTML del área de juego
        let flappyStartOverlay; // Elemento HTML de la superposición
        let startMessage; // Mensaje en la superposición ("Click to start")
        let scoreMessage; // Mensaje de puntuación en la superposición
        let liveScoreElement; // Elemento para mostrar la puntuación en vivo
        let flappyObstacles = []; // Array para guardar los obstáculos activos
        let flappyScore = 0; // Puntuación actual
        let highScore = 0; // Puntuación más alta (se guarda localmente)
        let flappyLastObstacleTime = 0; // Momento en que se creó el último obstáculo
        let flappyGameRequest; // ID para requestAnimationFrame (para poder cancelarlo)
        let birdY = 0; // Posición vertical del pájaro
        let birdVelocity = 0; // Velocidad vertical del pájaro
        let gravity; // Fuerza de gravedad
        let jumpImpulse; // Fuerza del salto
        let obstacleSpeed; // Velocidad horizontal de los obstáculos (se define abajo)
        let lastTimestamp = null; // Timestamp del último frame (para calcular delta time)
        let flappyEnded = false; // Flag para evitar que endFlappyGame se llame múltiples veces

        // --- Constantes de Configuración ---
        const OBSTACLE_GENERATION_INTERVAL_BASE = 2200; // (ms) Aumentado de 2000 para más espacio horizontal
        const VERTICAL_GAP = 200; // (px) Aumentado de 180 para más espacio vertical
        const BALANCE_LOCAL_STORAGE_KEY = 'cardGamePlayerBalance_v3'; // Clave para el saldo global
        const POINTS_PER_SCORE = 2; // Monedas a sumar por cada punto

        // --- Inicialización ---
        document.addEventListener('DOMContentLoaded', () => {
            // Seleccionar elementos del DOM
            flappyBird = document.getElementById("flappy-bird");
            flappyGameArea = document.getElementById("flappy-game-area");
            flappyStartOverlay = document.getElementById("flappy-start-overlay");
            startMessage = document.getElementById("start-message");
            scoreMessage = document.getElementById("score-message");
            liveScoreElement = document.getElementById("live-score");
            const flappyGame = document.getElementById("flappy-game");

            // Comprobar si los elementos esenciales existen
            if (!flappyBird || !flappyGameArea || !flappyStartOverlay || !flappyGame) {
                console.error("Error: No se encontraron uno o más elementos esenciales del juego.");
                return; // Detener la ejecución si falta algo crítico
            }


            // Ajustar parámetros según tamaño de pantalla (móvil vs escritorio)
            if (window.innerWidth < 600 || window.innerHeight < 600) {
                gravity = 0.3;
                jumpImpulse = -6;
                obstacleSpeed = 2.5;
            } else {
                gravity = 0.25;
                jumpImpulse = -7;
                obstacleSpeed = 3;
            }

            // Cargar la puntuación más alta guardada
            highScore = parseInt(localStorage.getItem('flappyHighScore')) || 0;

            // Listener para iniciar el juego al hacer clic/tocar la superposición
            flappyStartOverlay.addEventListener("click", startGameListener);

            // Listener para hacer saltar al pájaro (click)
            flappyGame.addEventListener("mousedown", (e) => {
                 // Solo procesar si el click NO fue en el overlay de inicio/fin
                if (flappyStartOverlay.style.display !== 'flex') {
                     flappyFlap();
                }
            });

             // Listener para hacer saltar al pájaro (touch) - CON DEBUG LOGS
            flappyGame.addEventListener("touchstart", (e) => {
                console.log("[DEBUG] Touchstart event detected on flappyGame");
                 // Solo procesar si el toque NO fue en el overlay de inicio/fin
                 // Comprobamos si el overlay está oculto (style.display === 'none')
                if (flappyStartOverlay.style.display === 'none') {
                    console.log("[DEBUG] Overlay is hidden. Game running:", flappyGameRunning);
                    if (flappyGameRunning) {
                        console.log("[DEBUG] Game is running, preventing default and flapping...");
                        e.preventDefault(); // Prevent default touch actions like scrolling
                        flappyFlap();       // Trigger the bird flap
                    } else {
                        console.log("[DEBUG] Game not running (but overlay hidden), touch ignored for flap.");
                    }
                } else {
                     console.log("[DEBUG] Touch on overlay detected, ignoring flap.");
                     // Si el overlay está visible, el click/touch en él es manejado por startGameListener
                }
            }, { passive: false }); // Necesario para poder usar preventDefault

            // Posicionar el pájaro y actualizar score inicial
            resetGameVariables();
            positionBird();
            updateLiveScore();

        });

        // --- Funciones del Juego ---

        function startGameListener() {
            console.log("[DEBUG] startGameListener called");
            flappyStartOverlay.style.display = "none"; // Ocultar overlay
            flappyStartOverlay.removeEventListener("click", startGameListener); // Evita múltiples listeners
            startFlappyGame();
        }

        function startFlappyGame() {
            console.log("[DEBUG] startFlappyGame called");
            if (flappyGameRunning) {
                console.log("[DEBUG] startFlappyGame aborted: game already running");
                return;
            }

            resetGameVariables();
            updateLiveScore();
            positionBird();
            removeExistingObstacles();

            flappyGameRunning = true;
            flappyEnded = false;
            lastTimestamp = null;
            // Asegurarse de que la animación no esté ya solicitada
            if(flappyGameRequest) cancelAnimationFrame(flappyGameRequest);
            flappyGameRequest = requestAnimationFrame(flappyGameLoop);
            console.log("[DEBUG] Game loop started with request ID:", flappyGameRequest);
        }

        function resetGameVariables() {
            console.log("[DEBUG] resetGameVariables called");
            flappyScore = 0;
            flappyObstacles = [];
            flappyLastObstacleTime = Date.now();
            if (flappyGameArea) {
                birdY = flappyGameArea.offsetHeight / 2;
            } else {
                birdY = window.innerHeight / 2; // Fallback
            }
            birdVelocity = 0;
            flappyEnded = false;
            if (flappyBird) {
             flappyBird.style.transform = 'translate(-50%, -50%) rotate(0deg)';
            }
        }

        function positionBird() {
            if (flappyBird) {
                flappyBird.style.top = birdY + "px";
            }
        }

        function removeExistingObstacles() {
            if (flappyGameArea) {
                const existingObstacles = flappyGameArea.querySelectorAll(".obstacle-flappy");
                existingObstacles.forEach(obs => obs.remove());
            }
            flappyObstacles = [];
        }

        function updateLiveScore() {
            if (liveScoreElement) {
                liveScoreElement.textContent = `Puntuación: ${flappyScore}`;
            }
        }

        function updateGlobalBalance() {
            try {
                const currentBalanceStr = localStorage.getItem(BALANCE_LOCAL_STORAGE_KEY);
                let currentBalance = 0;

                if (currentBalanceStr !== null) {
                    const parsed = parseInt(currentBalanceStr);
                    if (!isNaN(parsed)) {
                        currentBalance = parsed;
                    } else {
                        console.warn(`[DEBUG] Invalid balance in localStorage: ${currentBalanceStr}. Using 0.`);
                    }
                }

                const newBalance = currentBalance + POINTS_PER_SCORE;
                localStorage.setItem(BALANCE_LOCAL_STORAGE_KEY, newBalance.toString());
                 console.log(`[DEBUG] Global balance updated to: ${newBalance}`);

            } catch (error) {
                console.error("[DEBUG] Error updating global balance in localStorage:", error);
            }
        }


        function flappyGameLoop(timestamp) {
            if (!flappyGameRunning || !flappyBird || !flappyGameArea) {
                 console.log("[DEBUG] Game loop aborted: missing elements or game not running.");
                 return;
            }

            if (!lastTimestamp) lastTimestamp = timestamp;
            const delta = timestamp - lastTimestamp;
            lastTimestamp = timestamp;
            // Limitar delta para evitar saltos grandes si la pestaña estuvo inactiva
            const clampedDelta = Math.min(delta, 50); // Max delta de 50ms (~20fps min)
            const factor = clampedDelta / 9.67;

            // --- Física del Pájaro ---
            birdVelocity += gravity * factor;
            birdY += birdVelocity * factor;
            positionBird();
            const rotation = Math.max(-30, Math.min(60, birdVelocity * 4));
            flappyBird.style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;

            // --- Límites ---
             // Asegurarse de que flappyBird tiene dimensiones antes de comprobar
            if (flappyBird.offsetHeight > 0 && (birdY < 0 || birdY + flappyBird.offsetHeight > flappyGameArea.offsetHeight)) {
                console.log("[DEBUG] Bird out of bounds. Ending game.");
                endFlappyGame();
                return;
            }

            // --- Generar Obstáculos ---
            if (Date.now() - flappyLastObstacleTime > OBSTACLE_GENERATION_INTERVAL_BASE / (obstacleSpeed / 2)) {
                createFlappyObstacles();
                flappyLastObstacleTime = Date.now();
            }

            // --- Actualizar y Comprobar Obstáculos ---
            let shouldEndGame = false;
            let scoreUpdatedThisFrame = false;
            flappyObstacles = flappyObstacles.filter((obs) => {
                if (!obs.element) return false;
                obs.x -= obstacleSpeed * factor;
                obs.element.style.left = obs.x + "px";

                if (checkFlappyCollision(obs)) {
                    console.log("[DEBUG] Collision detected!");
                    shouldEndGame = true;
                }

                if (obs.type === "top" && !obs.passed && obs.x + obs.width < flappyBird.offsetLeft) {
                    obs.passed = true;
                    flappyScore++;
                    updateGlobalBalance();
                    scoreUpdatedThisFrame = true;
                }

                if (obs.x + obs.width < 0) {
                    obs.element.remove();
                    return false;
                }
                return true;
            });

            if (scoreUpdatedThisFrame) {
                updateLiveScore();
            }

            if (shouldEndGame) {
                endFlappyGame();
                return;
            }

            // Solicitar el próximo frame solo si el juego sigue corriendo
            if (flappyGameRunning) {
                flappyGameRequest = requestAnimationFrame(flappyGameLoop);
            }
        }

        function flappyFlap() {
            if (!flappyGameRunning) {
                 console.log("[DEBUG] flappyFlap ignored: game not running");
                 return;
            }
            console.log("[DEBUG] flappyFlap called!");
            birdVelocity = jumpImpulse;
        }

        function createFlappyObstacles() {
            if (!flappyGameArea) return;

            const gap = VERTICAL_GAP;
            const gameHeight = flappyGameArea.offsetHeight;
            const gameWidth = flappyGameArea.offsetWidth;
            const minHeight = 50;
            const maxTopHeight = gameHeight - gap - minHeight;

            if (maxTopHeight < minHeight) {
                console.warn("[DEBUG] Game height too small for obstacles.");
                return;
            }

            const topObstacleHeight = Math.floor(Math.random() * (maxTopHeight - minHeight + 1)) + minHeight;
            const bottomObstacleHeight = gameHeight - gap - topObstacleHeight;

            const topObstacle = document.createElement("div");
            topObstacle.classList.add("obstacle-flappy");
            topObstacle.style.height = topObstacleHeight + "px";
            topObstacle.style.left = gameWidth + "px";
            topObstacle.style.top = "0px";
            flappyGameArea.appendChild(topObstacle);

            const bottomObstacle = document.createElement("div");
            bottomObstacle.classList.add("obstacle-flappy");
            bottomObstacle.style.height = bottomObstacleHeight + "px";
            bottomObstacle.style.left = gameWidth + "px";
            bottomObstacle.style.top = (topObstacleHeight + gap) + "px";
            flappyGameArea.appendChild(bottomObstacle);

            flappyObstacles.push({ element: topObstacle, x: gameWidth, width: 60, type: "top", passed: false });
            flappyObstacles.push({ element: bottomObstacle, x: gameWidth, width: 60, type: "bottom", passed: false });
        }

        function checkFlappyCollision(obs) {
            if (!flappyBird || !obs || !obs.element) return false;
            const birdRect = flappyBird.getBoundingClientRect();
            const obsRect = obs.element.getBoundingClientRect();

            // Añadir un pequeño margen para detectar colisiones un poco antes si es necesario
            // const collisionMargin = 2;
            return (
                birdRect.right > obsRect.left // + collisionMargin
                && birdRect.left < obsRect.right // - collisionMargin
                && birdRect.bottom > obsRect.top // + collisionMargin
                && birdRect.top < obsRect.bottom // - collisionMargin
            );
        }

        function endFlappyGame() {
            console.log("[DEBUG] endFlappyGame called");
            if (flappyEnded) {
                console.log("[DEBUG] endFlappyGame aborted: already ended");
                return;
            }
            flappyEnded = true;
            flappyGameRunning = false; // Marcar juego como no corriendo
            if (flappyGameRequest) {
                cancelAnimationFrame(flappyGameRequest);
                console.log("[DEBUG] Game loop cancelled with request ID:", flappyGameRequest);
                flappyGameRequest = null; // Limpiar el ID
            }

            // Update high score if needed
            if (flappyScore > highScore) {
                highScore = flappyScore;
                localStorage.setItem('flappyHighScore', highScore);
            }

            const coinsEarned = flappyScore * POINTS_PER_SCORE;

            let finalBalanceStr = 'Error';
            try {
                const balanceFromStorage = localStorage.getItem(BALANCE_LOCAL_STORAGE_KEY);
                if (balanceFromStorage !== null) {
                    const parsedBalance = parseInt(balanceFromStorage);
                    if (!isNaN(parsedBalance)) {
                        finalBalanceStr = parsedBalance.toString();
                    } else {
                         console.warn(`[DEBUG] Invalid final balance in localStorage: ${balanceFromStorage}.`);
                         finalBalanceStr = 'Inválido';
                    }
                } else {
                     console.warn(`[DEBUG] Final balance key not found in localStorage. Displaying earned coins.`);
                     finalBalanceStr = coinsEarned.toString();
                }
            } catch (error) {
                console.error("[DEBUG] Error reading final balance from localStorage:", error);
            }

            if (startMessage && scoreMessage && flappyStartOverlay) {
                startMessage.textContent = "¡Has perdido!";
                scoreMessage.innerHTML = `Puntuación: ${flappyScore}<br>
                                          Monedas Ganadas: ${coinsEarned}<br>
                                          Saldo Total: ${finalBalanceStr} €<br>
                                          Mejor Puntuación: ${highScore}<br><br>
                                          Haz clic para volver a jugar`;
                flappyStartOverlay.style.display = "flex"; // Mostrar overlay

                // Re-attach listener to restart the game
                flappyStartOverlay.removeEventListener("click", startGameListener); // Limpiar anterior por si acaso
                flappyStartOverlay.addEventListener("click", startGameListener);
                 console.log("[DEBUG] Game over screen displayed. Listener attached.");
             } else {
                  console.error("[DEBUG] Error displaying game over screen: overlay elements not found.");
             }
        }

    </script>
</body>
</html>
