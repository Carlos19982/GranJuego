<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flappy Bird Standalone</title>
    <style>
        /* Estilos generales del cuerpo */
        body {
            margin: 0;
            height: 100vh; /* Asegura que el body ocupe toda la altura */
            display: flex; /* Centra el juego vertical y horizontalmente */
            align-items: center;
            justify-content: center;
            background-color: #f0f0f0; /* Un color de fondo suave */
            font-family: sans-serif;
            overflow: hidden; /* Evita barras de scroll */
        }

        /* Contenedor principal del juego */
        #flappy-game {
            position: relative; /* Necesario para posicionar elementos internos absolutamente */
            width: 100vw; /* Ocupa todo el ancho de la ventana */
            height: 100vh; /* Ocupa toda la altura de la ventana */
            max-width: 600px; /* Ancho máximo para pantallas grandes */
            max-height: 800px; /* Altura máxima para pantallas grandes */
            background-color: #87CEEB; /* Color cielo */
            overflow: hidden; /* Oculta lo que salga del área */
            border: 2px solid #333; /* Borde opcional */
            box-shadow: 0 5px 15px rgba(0,0,0,0.2); /* Sombra para darle profundidad */
            cursor: pointer; /* Indica que se puede hacer clic */
        }

        /* Área donde se mueven los elementos del juego */
        #flappy-game-area {
            position: relative;
            width: 100%;
            height: 100%;
        }

        /* Estilo del pájaro */
        #flappy-bird {
            position: absolute;
            left: 20%; /* Posición inicial horizontal */
            top: 50%; /* Posición inicial vertical */
            transform: translate(-50%, -50%); /* Centrado exacto */
            font-size: 2rem; /* Tamaño del pájaro (emoji) */
            user-select: none; /* Evita seleccionar el texto del pájaro */
            z-index: 10; /* Asegura que esté por encima de los obstáculos */
            transition: transform 0.1s ease-out; /* Suaviza la rotación al caer/subir */
        }

        /* Estilo de los obstáculos (tuberías) */
        .obstacle-flappy {
            position: absolute;
            width: 60px; /* Ancho de las tuberías */
            background-color: #2E8B57; /* Color verde oscuro */
            border: 2px solid #000; /* Borde negro */
            z-index: 5; /* Detrás del pájaro */
        }

        /* Superposición de inicio/fin */
        #flappy-start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6); /* Fondo semitransparente */
            display: flex;
            flex-direction: column; /* Apila los mensajes */
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            color: white;
            text-align: center;
            z-index: 100; /* Por encima de todo */
            cursor: pointer;
            line-height: 1.6; /* Mejora el espaciado entre líneas */
        }

        /* Estilo para el mensaje de puntuación final */
        #score-message {
            margin-top: 20px;
            font-size: 1.2rem;
            font-weight: bold;
        }

        /* Ocultar mensaje de puntuación inicialmente */
        #score-message:empty {
            display: none;
        }

        /* Estilo para el contador de puntuación en vivo */
        #live-score {
            position: absolute;
            top: 15px;
            right: 15px;
            color: white;
            font-size: 1.8rem;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7); /* Sombra para mejorar legibilidad */
            z-index: 50; /* Encima del juego, debajo del overlay de inicio/fin */
            user-select: none;
        }

        /* Estilo para el botón de salir (añadido) */
        #exit-button-flappy {
            position: absolute;
            top: 15px;
            left: 15px;
            padding: 8px 12px;
            background-color: rgba(50, 50, 50, 0.7); /* Fondo semitransparente oscuro */
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-size: 0.9rem;
            font-weight: bold;
            border: 1px solid rgba(255, 255, 255, 0.5);
            z-index: 101; /* Encima del overlay */
            transition: background-color 0.2s ease;
            user-select: none; /* Evitar selección */
        }
        #exit-button-flappy:hover {
            background-color: rgba(80, 80, 80, 0.8);
        }

    </style>
</head>
<body>
    <div id="flappy-game">
        <a href="../index.html" id="exit-button-flappy">
            &larr; Menú
        </a>

        <div id="flappy-game-area">
            <div id="flappy-bird">(*_*)</div>
            </div>
        <div id="live-score">Puntuación: 0</div>
        <div id="flappy-start-overlay">
            <div id="start-message">Haz clic para empezar</div>
            <div id="score-message"></div>
        </div>
    </div>

    <script>
        // --- Variables Globales del Juego ---
        let flappyGameRunning = false; // Indica si el juego está en curso
        let flappyBird; // Elemento HTML del pájaro
        let flappyGameArea; // Elemento HTML del área de juego
        let flappyStartOverlay; // Elemento HTML de la superposición
        let startMessage; // Mensaje en la superposición ("Click to start")
        let scoreMessage; // Mensaje de puntuación en la superposición
        let liveScoreElement; // Elemento para mostrar la puntuación en vivo
        let flappyObstacles = []; // Array para guardar los obstáculos activos
        let flappyScore = 0; // Puntuación actual
        let highScore = 0; // Puntuación más alta (se guarda localmente)
        let flappyLastObstacleTime = 0; // Momento en que se creó el último obstáculo
        let flappyGameRequest; // ID para requestAnimationFrame (para poder cancelarlo)
        let birdY = 0; // Posición vertical del pájaro
        let birdVelocity = 0; // Velocidad vertical del pájaro
        let gravity; // Fuerza de gravedad
        let jumpImpulse; // Fuerza del salto
        let obstacleSpeed; // Velocidad horizontal de los obstáculos (se define abajo)
        let lastTimestamp = null; // Timestamp del último frame (para calcular delta time)
        let flappyEnded = false; // Flag para evitar que endFlappyGame se llame múltiples veces

        // --- Constantes de Configuración ---
        const OBSTACLE_GENERATION_INTERVAL_BASE = 2200; // (ms) Aumentado de 2000 para más espacio horizontal
        const VERTICAL_GAP = 200; // (px) Aumentado de 180 para más espacio vertical
        const BALANCE_LOCAL_STORAGE_KEY = 'cardGamePlayerBalance_v3'; // Clave para el saldo global
        const POINTS_PER_SCORE = 2; // Monedas a sumar por cada punto

        // --- Inicialización ---
        document.addEventListener('DOMContentLoaded', () => {
            // Seleccionar elementos del DOM
            flappyBird = document.getElementById("flappy-bird");
            flappyGameArea = document.getElementById("flappy-game-area");
            flappyStartOverlay = document.getElementById("flappy-start-overlay");
            startMessage = document.getElementById("start-message");
            scoreMessage = document.getElementById("score-message");
            liveScoreElement = document.getElementById("live-score");
            const flappyGame = document.getElementById("flappy-game");

            // Ajustar parámetros según tamaño de pantalla (móvil vs escritorio)
            if (window.innerWidth < 600 || window.innerHeight < 600) {
                gravity = 0.3;
                jumpImpulse = -6;
                obstacleSpeed = 2.5;
            } else {
                gravity = 0.25;
                jumpImpulse = -7;
                obstacleSpeed = 3;
            }

            // Cargar la puntuación más alta guardada
            highScore = parseInt(localStorage.getItem('flappyHighScore')) || 0;

            // Listener para iniciar el juego al hacer clic/tocar la superposición
            flappyStartOverlay.addEventListener("click", startGameListener);

            // Listener para hacer saltar al pájaro
            flappyGame.addEventListener("mousedown", flappyFlap);
            flappyGame.addEventListener("touchstart", (e) => {
                e.preventDefault(); // Evitar comportamiento por defecto (como zoom o scroll)
                flappyFlap();
            });

            // Evitar que el clic en el botón de salir inicie el salto
            const exitButton = document.getElementById('exit-button-flappy');
            if (exitButton) {
                exitButton.addEventListener('mousedown', (e) => e.stopPropagation());
                exitButton.addEventListener('touchstart', (e) => e.stopPropagation());
            }


            // Posicionar el pájaro y actualizar score inicial
            resetGameVariables();
            positionBird();
            updateLiveScore();

        });

        // --- Funciones del Juego ---

        function startGameListener() {
            flappyStartOverlay.style.display = "none";
            flappyStartOverlay.removeEventListener("click", startGameListener); // Evita múltiples listeners
            startFlappyGame();
        }

        function startFlappyGame() {
            if (flappyGameRunning) return;

            resetGameVariables();
            updateLiveScore();
            positionBird();
            removeExistingObstacles();

            flappyGameRunning = true;
            flappyEnded = false;
            lastTimestamp = null;
            flappyGameRequest = requestAnimationFrame(flappyGameLoop);
        }

        function resetGameVariables() {
            flappyScore = 0;
            flappyObstacles = [];
            flappyLastObstacleTime = Date.now();
             // Ensure flappyGameArea is defined before accessing offsetHeight
            if (flappyGameArea) {
                birdY = flappyGameArea.offsetHeight / 2;
            } else {
                birdY = window.innerHeight / 2; // Fallback if area not ready
            }
            birdVelocity = 0;
            flappyEnded = false;
            if (flappyBird) {
             flappyBird.style.transform = 'translate(-50%, -50%) rotate(0deg)';
            }
        }

        function positionBird() {
            if (flappyBird) {
                flappyBird.style.top = birdY + "px";
            }
        }

        function removeExistingObstacles() {
             // Ensure flappyGameArea is defined
            if (flappyGameArea) {
                const existingObstacles = flappyGameArea.querySelectorAll(".obstacle-flappy");
                existingObstacles.forEach(obs => obs.remove());
            }
            flappyObstacles = [];
        }

        function updateLiveScore() {
            if (liveScoreElement) {
                liveScoreElement.textContent = `Puntuación: ${flappyScore}`;
            }
        }

        function updateGlobalBalance() {
            try {
                const currentBalanceStr = localStorage.getItem(BALANCE_LOCAL_STORAGE_KEY);
                let currentBalance = 0;

                if (currentBalanceStr !== null) {
                    const parsed = parseInt(currentBalanceStr);
                    if (!isNaN(parsed)) {
                        currentBalance = parsed;
                    } else {
                        console.warn(`Valor inválido en localStorage para ${BALANCE_LOCAL_STORAGE_KEY}. Se usará 0 como base.`);
                    }
                }

                const newBalance = currentBalance + POINTS_PER_SCORE;
                localStorage.setItem(BALANCE_LOCAL_STORAGE_KEY, newBalance.toString());

            } catch (error) {
                console.error("Error al actualizar el saldo global en localStorage:", error);
            }
        }


        function flappyGameLoop(timestamp) {
            if (!flappyGameRunning || !flappyBird || !flappyGameArea) return; // Add checks for elements

            if (!lastTimestamp) lastTimestamp = timestamp;
            const delta = timestamp - lastTimestamp;
            lastTimestamp = timestamp;
            const factor = delta / 9.67; // Ajusta este divisor si el juego va muy rápido/lento

            // --- Física del Pájaro ---
            birdVelocity += gravity * factor;
            birdY += birdVelocity * factor;
            positionBird();
            const rotation = Math.max(-30, Math.min(60, birdVelocity * 4)); // Limita la rotación
            flappyBird.style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;

            // --- Límites ---
            // Comprobar si el pájaro toca el techo o el suelo
            if (birdY < 0 || birdY + flappyBird.offsetHeight > flappyGameArea.offsetHeight) {
                endFlappyGame();
                return;
            }

            // --- Generar Obstáculos ---
            // Genera un nuevo par de obstáculos si ha pasado suficiente tiempo
            if (Date.now() - flappyLastObstacleTime > OBSTACLE_GENERATION_INTERVAL_BASE / (obstacleSpeed / 2)) {
                createFlappyObstacles();
                flappyLastObstacleTime = Date.now();
            }

            // --- Actualizar y Comprobar Obstáculos ---
            let shouldEndGame = false;
            let scoreUpdatedThisFrame = false;
            // Recorre los obstáculos existentes
            flappyObstacles = flappyObstacles.filter((obs) => {
                if (!obs.element) return false; // Skip if element is missing (safety check)

                // Mover el obstáculo hacia la izquierda
                obs.x -= obstacleSpeed * factor;
                obs.element.style.left = obs.x + "px";

                // Comprobar colisión con el pájaro
                if (checkFlappyCollision(obs)) {
                    shouldEndGame = true; // Marcar para terminar el juego si hay colisión
                }

                // Comprobar si el pájaro ha pasado un obstáculo superior (para puntuar)
                if (obs.type === "top" && !obs.passed && obs.x + obs.width < flappyBird.offsetLeft) {
                    obs.passed = true; // Marcar como pasado
                    flappyScore++; // Incrementar puntuación
                    updateGlobalBalance(); // Actualizar saldo global (si aplica)
                    scoreUpdatedThisFrame = true; // Marcar que la puntuación cambió
                }

                // Eliminar obstáculos que ya salieron de la pantalla
                if (obs.x + obs.width < 0) {
                    obs.element.remove(); // Quitar del DOM
                    return false; // Filtrar fuera del array
                }
                return true; // Mantener el obstáculo en el array
            });

            // Actualizar el marcador de puntuación si cambió
            if (scoreUpdatedThisFrame) {
                updateLiveScore();
            }

            // Terminar el juego si hubo colisión
            if (shouldEndGame) {
                endFlappyGame();
                return;
            }

            // Solicitar el próximo frame de animación
            flappyGameRequest = requestAnimationFrame(flappyGameLoop);
        }

        function flappyFlap() {
            // Impulsa al pájaro hacia arriba al hacer clic/tocar
            if (!flappyGameRunning) return; // No hacer nada si el juego no está activo
            birdVelocity = jumpImpulse; // Aplica la fuerza de salto (negativa para ir hacia arriba)
        }

        function createFlappyObstacles() {
            if (!flappyGameArea) return; // Ensure game area exists

            const gap = VERTICAL_GAP; // Espacio vertical entre tuberías
            const gameHeight = flappyGameArea.offsetHeight;
            const gameWidth = flappyGameArea.offsetWidth;
            const minHeight = 50; // Altura mínima de una tubería
            const maxTopHeight = gameHeight - gap - minHeight; // Altura máxima posible para la tubería superior

             // Ensure maxTopHeight is not negative if gameHeight is too small
            if (maxTopHeight < minHeight) {
                console.warn("Game height too small for obstacles and gap.");
                return; // Optionally skip obstacle creation
            }

            // Calcular alturas aleatorias para las tuberías
            const topObstacleHeight = Math.floor(Math.random() * (maxTopHeight - minHeight + 1)) + minHeight;
            const bottomObstacleHeight = gameHeight - gap - topObstacleHeight;

            // Crear elemento DOM para la tubería superior
            const topObstacle = document.createElement("div");
            topObstacle.classList.add("obstacle-flappy");
            topObstacle.style.height = topObstacleHeight + "px";
            topObstacle.style.left = gameWidth + "px"; // Empieza fuera de la pantalla a la derecha
            topObstacle.style.top = "0px"; // Pegada al techo
            flappyGameArea.appendChild(topObstacle); // Añadir al área de juego

            // Crear elemento DOM para la tubería inferior
            const bottomObstacle = document.createElement("div");
            bottomObstacle.classList.add("obstacle-flappy");
            bottomObstacle.style.height = bottomObstacleHeight + "px";
            bottomObstacle.style.left = gameWidth + "px"; // Empieza fuera de la pantalla a la derecha
            bottomObstacle.style.top = (topObstacleHeight + gap) + "px"; // Posicionada debajo del hueco
            flappyGameArea.appendChild(bottomObstacle); // Añadir al área de juego

            // Guardar referencias y datos de los obstáculos en el array
            flappyObstacles.push({ element: topObstacle, x: gameWidth, width: 60, type: "top", passed: false });
            flappyObstacles.push({ element: bottomObstacle, x: gameWidth, width: 60, type: "bottom", passed: false });
        }

        function checkFlappyCollision(obs) {
            if (!flappyBird || !obs || !obs.element) return false; // Add check for obs and its element

            // Obtener los rectángulos de colisión del pájaro y el obstáculo
            const birdRect = flappyBird.getBoundingClientRect();
            const obsRect = obs.element.getBoundingClientRect();

            // Comprobar si los rectángulos se solapan
            return (
                birdRect.right > obsRect.left &&   // El lado derecho del pájaro está más allá del izquierdo del obstáculo
                birdRect.left < obsRect.right &&    // El lado izquierdo del pájaro está antes del derecho del obstáculo
                birdRect.bottom > obsRect.top &&  // La parte inferior del pájaro está por debajo de la superior del obstáculo
                birdRect.top < obsRect.bottom     // La parte superior del pájaro está por encima de la inferior del obstáculo
            );
        }

        // --- Función Modificada para Terminar el Juego ---
        function endFlappyGame() {
            if (flappyEnded) return; // Evitar ejecuciones múltiples
            flappyEnded = true; // Marcar como terminado
            flappyGameRunning = false; // Detener el estado de juego activo
            if (flappyGameRequest) { // Check if request exists before cancelling
              cancelAnimationFrame(flappyGameRequest); // Detener el bucle de animación
            }


            // Actualizar la puntuación más alta si se superó
            if (flappyScore > highScore) {
                highScore = flappyScore;
                localStorage.setItem('flappyHighScore', highScore); // Guardar en localStorage
            }

            // Calcular monedas ganadas en esta partida
            const coinsEarned = flappyScore * POINTS_PER_SCORE;

            // Leer el saldo final actualizado desde localStorage
            let finalBalanceStr = 'Error'; // Valor por defecto si hay problemas
            try {
                const balanceFromStorage = localStorage.getItem(BALANCE_LOCAL_STORAGE_KEY);
                if (balanceFromStorage !== null) {
                    const parsedBalance = parseInt(balanceFromStorage);
                    if (!isNaN(parsedBalance)) {
                        finalBalanceStr = parsedBalance.toString(); // Usar el valor parseado
                    } else {
                         console.warn(`Valor final inválido en localStorage para ${BALANCE_LOCAL_STORAGE_KEY}.`);
                         finalBalanceStr = 'Inválido';
                    }
                } else {
                     // Si la clave de saldo nunca existió, mostrar las monedas ganadas como total potencial
                     console.warn(`No se encontró valor final en localStorage para ${BALANCE_LOCAL_STORAGE_KEY}. Mostrando monedas ganadas.`);
                     finalBalanceStr = coinsEarned.toString(); // Mostrar al menos lo que se ganó
                }
            } catch (error) {
                console.error("Error al leer el saldo final desde localStorage:", error);
            }

             // Asegurarse de que los elementos de la superposición existen antes de actualizarlos
            if (startMessage && scoreMessage && flappyStartOverlay) {
                // Mostrar mensaje de "Game Over" con puntuación, monedas y saldo
                startMessage.textContent = "¡Has perdido!";
                scoreMessage.innerHTML = `Puntuación: ${flappyScore}<br>
                                          Monedas Ganadas: ${coinsEarned}<br>
                                          Saldo Total: ${finalBalanceStr} €<br>
                                          Mejor Puntuación: ${highScore}<br><br>
                                          Haz clic para volver a jugar`;
                flappyStartOverlay.style.display = "flex"; // Mostrar la superposición

                // Añadir listener para reiniciar el juego (asegurándose de que solo haya uno)
                flappyStartOverlay.removeEventListener("click", startGameListener); // Quitar listener anterior si existe
                flappyStartOverlay.addEventListener("click", startGameListener); // Añadir nuevo listener
             }
        }


    </script>
</body>
</html>
