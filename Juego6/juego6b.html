<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Bolsa - Estado Persistente</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* Estilos generales (sin cambios) */
        body { background-color: #f3f4f6; font-family: 'Inter', sans-serif; }
        .price-up { color: #10b981; }
        .price-down { color: #ef4444; }
        input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        input[type=number] { -moz-appearance: textfield; }
        .action-button { @apply px-3 py-1 text-xs font-medium text-white rounded shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2; }
        .buy-button { @apply bg-emerald-600 hover:bg-emerald-700 focus:ring-emerald-500 action-button; }
        .sell-button { @apply bg-rose-600 hover:bg-rose-700 focus:ring-rose-500 action-button; }
        .control-button { @apply px-4 py-2 font-semibold text-white rounded shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 transition duration-150 ease-in-out; }
        .pause-button { @apply bg-blue-600 hover:bg-blue-700 focus:ring-blue-500 control-button; }
        .resume-button { @apply bg-red-600 hover:bg-red-700 focus:ring-red-500 control-button; }
        .history-button { @apply bg-gray-600 hover:bg-gray-700 focus:ring-gray-500 control-button; }
        .chart-container { height: 300px; position: relative; margin-top: 1.5rem; }
        .toggle-checkbox:checked { right: 0; border-color: #68D391; }
        .toggle-checkbox:checked + .toggle-label { background-color: #68D391; }
        .toggle-checkbox { @apply absolute block w-4 h-4 mt-1 ml-1 rounded-full bg-white border-2 appearance-none cursor-pointer; transition: right 0.2s ease-in-out; }
        .toggle-label { @apply block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer; width: 40px; transition: background-color 0.2s ease-in-out; }
        .sl-tp-label { @apply text-xs font-medium text-gray-600; }
        /* Estilos Modal Historial (sin cambios) */
        .modal { @apply fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50 flex items-center justify-center; }
        .modal-content { @apply relative mx-auto p-5 border w-full max-w-2xl shadow-lg rounded-md bg-white; }
        .modal-close { @apply absolute top-0 right-0 cursor-pointer p-4 text-xl font-bold text-gray-700 hover:text-red-500; }
        .history-list-item { @apply border-b border-gray-200 py-3 text-sm; }
        .history-main-line span { @apply mr-2; }
        .history-gain-loss { @apply text-xs pl-4; }
        .history-type-BUY { @apply font-semibold text-green-600; }
        .history-type-SELL { @apply font-semibold text-red-600; }
        .history-type-SL { @apply font-semibold text-red-800; }
        .history-type-TP { @apply font-semibold text-green-800; }
        /* Estilo para inputs pequeños (sin cambios) */
        .portfolio-qty-input { @apply px-2 py-1 border border-gray-300 rounded text-sm text-center focus:ring-1 focus:ring-blue-500 focus:border-blue-500; }
         /* Estilo para el botón de menú (sin cambios) */
        .menu-link-button { @apply inline-block bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-150 ease-in-out text-sm no-underline focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500; }
        /* Style for cash element to indicate interactivity (sin cambios) */
        #cash { cursor: pointer; user-select: none; -webkit-user-select: none; }
        /* Styles for the new event notification banner (sin cambios) */
        #event-notification-banner {
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
            opacity: 0;
            transform: translateY(-100%);
            pointer-events: none;
        }
        #event-notification-banner.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto; /* Allow interaction when visible */
        }

    </style>
     <link rel="preconnect" href="https://rsms.me/">
     <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
     <style> body { font-family: 'Inter var', sans-serif; } </style> 
</head>
<body class="min-h-screen">

    <div id="event-notification-banner" class="fixed top-4 left-1/2 -translate-x-1/2 z-[1000] px-6 py-3 rounded-lg shadow-lg text-white text-sm font-semibold bg-indigo-600 hidden">
        </div>

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        <header class="mb-8 p-4 bg-white rounded-lg shadow-md">
             <h1 class="text-2xl md:text-3xl font-bold text-gray-800 text-center mb-4">Simulador de Bolsa</h1>
             <div class="flex flex-wrap justify-around text-center text-sm md:text-base text-gray-700">
                 <div class="info-item mx-2 my-1"><span class="font-semibold">Dinero:</span> $<span id="cash">Cargando...</span></div>
                 <div class="info-item mx-2 my-1"><span class="font-semibold">Valor Cartera:</span> $<span id="portfolio-value">0,00</span></div>
                 <div class="info-item mx-2 my-1"><span class="font-semibold">Valor Total:</span> $<span id="total-value">Cargando...</span></div>
             </div>
          </header>

        <main class="grid grid-cols-1 md:grid-cols-2 gap-6 md:gap-8 mb-8">
            <section id="market-chart-section" class="bg-white p-4 md:p-6 rounded-lg shadow-md">
                <h2 class="text-xl md:text-2xl font-semibold text-gray-800 mb-4">Mercado de Acciones</h2>
                <div class="chart-container mb-6">
                    <canvas id="stockChart"></canvas>
                </div>
            </section>

             <section id="portfolio-section" class="bg-white p-4 md:p-6 rounded-lg shadow-md">
                <h2 class="text-xl md:text-2xl font-semibold text-gray-800 mb-4">Mi Cartera</h2>
                <div id="portfolio" class="space-y-4">
                    <p id="empty-portfolio-msg" class="text-gray-500">Aún no tienes acciones.</p>
                </div>
             </section>

             <section id="market-list-section" class="bg-white p-4 md:p-6 rounded-lg shadow-md md:col-span-2">
                <h3 class="text-lg font-semibold text-gray-700 mb-3">Acciones Disponibles</h3>
                <div id="stock-market" class="space-y-4">
                    <p class="text-gray-500">Cargando mercado...</p>
                </div>
             </section>
        </main>

        <footer class="text-center space-y-4 pb-8">
             <div id="message-box" class="p-3 bg-gray-100 border border-gray-300 rounded-md text-gray-700 min-h-[40px] text-sm md:text-base">
                 Cargando simulador...
             </div>
             <div class="controls flex justify-center space-x-4">
                 <button id="pause-resume-btn" class="pause-button">Pausar</button>
                 <button id="history-btn" onclick="showHistory()" class="history-button">Mostrar Historial</button>
             </div>
             <div class="mt-4">
                 <a href="../index.html" id="exit-button" class="menu-link-button">
                     &larr; Menú
                 </a>
             </div>
        </footer>

         <div id="history-modal" class="modal hidden">
             <div class="modal-content">
                 <span class="modal-close" onclick="closeHistory()">&times;</span>
                 <h3 class="text-xl font-semibold mb-4 text-gray-800">Historial de Transacciones</h3>
                 <div class="max-h-96 overflow-y-auto">
                     <ul id="history-list">
                         <li class="text-gray-500">No hay transacciones todavía.</li>
                     </ul>
                 </div>
             </div>
          </div>

    </div>

    <script>
        // --- Constantes de Storage ---
        const BALANCE_LOCAL_STORAGE_KEY = 'cardGamePlayerBalance_v3';
        const GAME6_INVESTMENT_SESSION_KEY = 'game6InitialInvestment';
        const STOCK_GAME_STATE_KEY = 'stockSimGameState_v2';
        const DEFAULT_BALANCE = 5000;

        // --- Configuración Inicial ---
        let cash = 10000; // Será sobrescrito al cargar
        let portfolio = {};
        const initialStockData = [
            { symbol: 'TECH', name: 'Tech Corp 💻', price: 15.00, volatility: 0.032, trend: 0.00002, color: '#3B82F6', showOnChart: true },
            { symbol: 'FOOD', name: 'Foodies Inc 🍔', price: 5.00, volatility: 0.016, trend: 0.00001, color: '#F59E0B', showOnChart: true },
            { symbol: 'GAME', name: 'GameDev Co 🎮', price: 8.00, volatility: 0.048, trend: -0.00001, color: '#8B5CF6', showOnChart: true },
            { symbol: 'FIN', name: 'Finance Hub 💰', price: 20.00, volatility: 0.024, trend: 0.000015, color: '#10B981', showOnChart: true },
            { symbol: 'ECO', name: 'Eco Energy 🌿', price: 7.00, volatility: 0.040, trend: 0.00003, color: '#6B7280', showOnChart: true }
        ];
        let stocks = [];
        let transactionHistory = []; // Se inicializará como vacío al cargar
        const stopLossThreshold = -4.0;
        const takeProfitThreshold = 5.0;
        let gameInterval = null;
        let isPaused = false;
        const updateInterval = 10000;
        const maxHistoryLength = 60;
        let tickCounter = 0;
        let initialInvestment = 0; // Se leerá de sessionStorage para cálculo de G/P al salir

        // Constantes para Tendencia Dinámica
        const TREND_UPDATE_TICKS = 5;
        const TREND_CHANGE_AMOUNT = 0.000025;
        const MAX_TREND = 0.00015;
        const MIN_TREND = -0.00015;

        // Variable para el atajo secreto
        let showTrendIndicator = false;

        // Event System Variables & Config
        const EVENT_PROBABILITY = 0.10;
        const MAX_ACTIVE_EVENTS = 2;
        let activeEvents = [];
        // --- Lista de Eventos (con ajustes previos aplicados) ---
        const marketEvents = [
             { name: "Optimismo Global", message: "📈 ¡Optimismo en los mercados globales! Ligera tendencia alcista general.", target: 'ALL', duration: 3, volatility_modifier: 0.8, trend_modifier: 0.00007 },
             { name: "Temor a Recesión", message: "📉 ¡Aumentan los temores de recesión! Tendencia bajista y volatilidad alta.", target: 'ALL', duration: 3, volatility_modifier: 1.6, trend_modifier: -0.00008 },
             { name: "Avance Tecnológico", message: "🚀 ¡Anunciado un avance tecnológico clave! El sector TECH sube con fuerza.", target: 'TECH', duration: 3, volatility_modifier: 0.8, trend_modifier: 0.0003 },
             { name: "Regulación Tecnológica", message: "🏛️ ¡Nuevas regulaciones afectan a Tech Corp! Fuerte caída de confianza.", target: 'TECH', duration: 3, volatility_modifier: 1.7, trend_modifier: -0.00015 },
             { name: "Resultados Bancarios Positivos", message: "🏦 ¡Resultados bancarios superan expectativas! El sector FIN celebra.", target: 'FIN', duration: 3, volatility_modifier: 0.85, trend_modifier: 0.00015 },
             { name: "Caída del Petróleo", message: "🛢️ ¡Caída inesperada del precio del petróleo! Duro golpe para Eco Energy.", target: 'ECO', duration: 3, volatility_modifier: 1.9, trend_modifier: -0.00018 },
             { name: "Éxito Viral de Juego", message: "🎉 ¡GameDev Co lanza un éxito viral! Las acciones se disparan.", target: 'GAME', duration: 3, volatility_modifier: 0.7, trend_modifier: 0.0004 },
             { name: "Problemas Suministro Comida", message: "🚚 ¡Problemas en la cadena de suministro afectan a Foodies Inc!", target: 'FOOD', duration: 3, volatility_modifier: 1.4, trend_modifier: -0.00009 },
             { name: "Datos de Inflación", message: "📊 ¡Datos de inflación generan alta incertidumbre y volatilidad!", target: 'ALL', duration: 3, volatility_modifier: 1.7, trend_modifier: -0.00003 },
             { name: "Inversión en Energía Verde", message: "💡 ¡Gobierno anuncia fuerte inversión en energía verde! ECO sube.", target: 'ECO', duration: 3, volatility_modifier: 0.9, trend_modifier: 0.0002 },
             { name: "Fallo Seguridad Tech", message: "🔒 ¡Fallo de seguridad crítico descubierto en Tech Corp!", target: 'TECH', duration: 3, volatility_modifier: 1.8, trend_modifier: -0.00020 },
             { name: "Alianza Estratégica Finanzas", message: "🤝 ¡Finance Hub anuncia alianza estratégica clave!", target: 'FIN', duration: 3, volatility_modifier: 0.9, trend_modifier: 0.00012 },
             { name: "Retraso Juego Esperado", message: "⏳ ¡GameDev Co retrasa indefinidamente su juego más esperado!", target: 'GAME', duration: 3, volatility_modifier: 1.5, trend_modifier: -0.00015 },
             { name: "Tendencia Saludable Comida", message: "🥗 ¡Tendencia de comida saludable impulsa las ventas de Foodies Inc!", target: 'FOOD', duration: 3, volatility_modifier: 0.95, trend_modifier: 0.00010 },
             { name: "Desastre Natural", message: "🌪️ ¡Desastre natural impacta la economía global!", target: 'ALL', duration: 3, volatility_modifier: 1.9, trend_modifier: -0.00010 },
             { name: "Subida Tipos Interés", message: "💸 ¡Banco central sube tipos de interés inesperadamente!", target: 'ALL', duration: 3, volatility_modifier: 1.4, trend_modifier: -0.00005 },
             { name: "Descubrimiento Energía Limpia", message: "⚡ ¡Eco Energy anuncia un descubrimiento prometedor en energía limpia!", target: 'ECO', duration: 3, volatility_modifier: 0.8, trend_modifier: 0.00025 },
        ];
        let eventNotificationTimeout = null;


        // --- Elementos del DOM (sin cambios) ---
        const cashEl = document.getElementById('cash');
        const portfolioValueEl = document.getElementById('portfolio-value');
        const totalValueEl = document.getElementById('total-value');
        const stockMarketEl = document.getElementById('stock-market');
        const portfolioEl = document.getElementById('portfolio');
        const emptyPortfolioMsgEl = document.getElementById('empty-portfolio-msg');
        const pauseResumeBtn = document.getElementById('pause-resume-btn');
        const messageBoxEl = document.getElementById('message-box');
        const chartCanvas = document.getElementById('stockChart');
        const historyModal = document.getElementById('history-modal');
        const historyListEl = document.getElementById('history-list');
        const exitButton = document.getElementById('exit-button');
        const eventNotificationBanner = document.getElementById('event-notification-banner');
        let stockChart = null;

        // --- Funciones del Juego (sin cambios en la mayoría) ---
        // ... (showMessage, showEventNotification, formatCurrency, etc. sin cambios) ...

        function showMessage(msg, type = 'info') {
            messageBoxEl.textContent = msg;
            messageBoxEl.className = 'p-3 border rounded-md min-h-[40px] text-sm md:text-base'; // Reset classes
            switch (type) {
                case 'error': messageBoxEl.classList.add('bg-red-100', 'border-red-400', 'text-red-700'); break;
                case 'success': messageBoxEl.classList.add('bg-green-100', 'border-green-400', 'text-green-700'); break;
                case 'info': default: messageBoxEl.classList.add('bg-yellow-100', 'border-yellow-400', 'text-yellow-700'); break;
            }
        }

        function showEventNotification(msg) {
             if (!eventNotificationBanner) return;
             eventNotificationBanner.textContent = msg;
             eventNotificationBanner.classList.remove('hidden');
             void eventNotificationBanner.offsetWidth; // Reflow
             eventNotificationBanner.classList.add('visible');
             if (eventNotificationTimeout) { clearTimeout(eventNotificationTimeout); }
             eventNotificationTimeout = setTimeout(() => {
                 eventNotificationBanner.classList.remove('visible');
                 // Delay hiding to allow fade out animation
                 setTimeout(() => { if (!eventNotificationBanner.classList.contains('visible')) { eventNotificationBanner.classList.add('hidden'); } }, 500);
                 eventNotificationTimeout = null;
             }, 15000); // Show for 15 seconds
         }

        function formatCurrency(amount) {
            if (typeof amount !== 'number' || isNaN(amount)) { return '0,00'; }
            return amount.toLocaleString('es-ES', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        }

        function formatTimestamp(date) {
            if (!(date instanceof Date) || isNaN(date.getTime())) return 'Fecha inválida'; // Check for valid Date object
            return date.toLocaleString('es-ES', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit' });
        }

        function updateGameInfo() {
            cashEl.textContent = formatCurrency(cash);
            const currentPortfolioValue = calculatePortfolioValue(); // Recalculate here
            portfolioValueEl.textContent = formatCurrency(currentPortfolioValue);
            totalValueEl.textContent = formatCurrency(cash + currentPortfolioValue);
        }

        function buildStockMarketList() {
            stockMarketEl.innerHTML = '';
            if (stocks.length === 0) { stockMarketEl.innerHTML = '<p class="text-gray-500">No hay acciones disponibles.</p>'; return; }
            stocks.forEach(stock => {
                const stockDiv = document.createElement('div');
                stockDiv.id = `stock-item-${stock.symbol}`;
                stockDiv.className = 'stock-item border border-gray-200 rounded-lg p-3 shadow-sm flex flex-wrap justify-between items-center';
                stockDiv.innerHTML = `
                    <div class="flex-grow flex items-center mb-2 md:mb-0 mr-4">
                        <div class="relative inline-block w-10 mr-3 align-middle select-none transition duration-200 ease-in">
                            <input type="checkbox" name="toggle-${stock.symbol}" id="toggle-${stock.symbol}" class="toggle-checkbox" ${stock.showOnChart ? 'checked' : ''} onchange="toggleChartVisibility('${stock.symbol}')"/>
                            <label for="toggle-${stock.symbol}" class="toggle-label"></label>
                        </div>
                        <div class="stock-info">
                            <div class="stock-name font-semibold text-gray-700">${stock.name} (${stock.symbol})</div>
                            <div class="stock-price text-sm text-gray-600">
                                Precio: <span id="price-value-${stock.symbol}">$${formatCurrency(stock.price)}</span>
                                <span class="price-change-indicator font-bold ml-2" id="change-indicator-${stock.symbol}"></span>
                            </div>
                        </div>
                    </div>
                    <div class="actions flex items-center space-x-2 mt-2 md:mt-0 w-full md:w-auto justify-end">
                        <input type="number" id="buy-qty-${stock.symbol}" min="1" value="1" class="portfolio-qty-input w-16">
                        <button onclick="buyStock('${stock.symbol}')" class="buy-button">Comprar</button>
                    </div>`;
                stockMarketEl.appendChild(stockDiv);
                updateStockItemDisplay(stock); // Update initial display correctly
            });
        }

        function updateStockItemDisplay(stock) {
             const priceValueEl = document.getElementById(`price-value-${stock.symbol}`);
             const changeIndicatorEl = document.getElementById(`change-indicator-${stock.symbol}`);
             if (!priceValueEl || !changeIndicatorEl) return;

             // Ensure lastPrice exists before calculating change
             const priceChange = (stock.lastPrice !== undefined && stock.lastPrice !== null) ? stock.price - stock.lastPrice : 0;

             const changeIndicatorSymbol = priceChange > 0 ? '▲' : (priceChange < 0 ? '▼' : '');
             const changeClass = priceChange > 0 ? 'price-up' : (priceChange < 0 ? 'price-down' : 'text-gray-500');

             priceValueEl.textContent = `$${formatCurrency(stock.price)}`;
             changeIndicatorEl.textContent = `${changeIndicatorSymbol} ${formatCurrency(Math.abs(priceChange))}`;
             changeIndicatorEl.className = `price-change-indicator font-bold ml-2 ${changeClass}`;
         }


        function renderStockMarket() {
            stocks.forEach(stock => { if (document.getElementById(`stock-item-${stock.symbol}`)) { updateStockItemDisplay(stock); } });
        }

        function calculatePortfolioValue() {
            let currentPortfolioValue = 0;
            Object.keys(portfolio).forEach(symbol => {
                const stock = stocks.find(s => s.symbol === symbol);
                const portfolioItem = portfolio[symbol];
                if (stock && portfolioItem && portfolioItem.quantity > 0) { currentPortfolioValue += portfolioItem.quantity * stock.price; }
            });
            return currentPortfolioValue;
        }

        function renderPortfolio() {
            portfolioEl.innerHTML = '';
            const portfolioSymbols = Object.keys(portfolio);
            let currentPortfolioValue = 0; // Recalculate for header update

            if (portfolioSymbols.length === 0 || portfolioSymbols.every(sym => !portfolio[sym] || portfolio[sym].quantity <= 0)) {
                portfolioEl.appendChild(emptyPortfolioMsgEl);
                emptyPortfolioMsgEl.style.display = 'block';
            } else {
                emptyPortfolioMsgEl.style.display = 'none';
                portfolioSymbols.forEach(symbol => {
                    const stock = stocks.find(s => s.symbol === symbol);
                    const portfolioItem = portfolio[symbol];

                    // Skip if item is invalid or quantity is zero
                    if (!stock || !portfolioItem || portfolioItem.quantity <= 0) {
                        if (portfolio[symbol]) delete portfolio[symbol]; // Clean up empty entries
                        return;
                    };

                    const marketValue = portfolioItem.quantity * stock.price;
                    const costBasis = portfolioItem.quantity * portfolioItem.avgPrice;
                    const gainLoss = marketValue - costBasis;
                    const gainLossPercent = portfolioItem.avgPrice !== 0 ? (gainLoss / costBasis) * 100 : 0;
                    const gainLossClass = gainLoss >= 0 ? 'price-up' : 'price-down';
                    currentPortfolioValue += marketValue; // Add to total portfolio value

                    let trendSymbol = '';
                    if (showTrendIndicator && stock) {
                        if (stock.trend > 0) { trendSymbol = '<span class="price-up ml-1 text-xs">▲</span>'; }
                        else if (stock.trend < 0) { trendSymbol = '<span class="price-down ml-1 text-xs">▼</span>'; }
                    }

                    const portfolioDiv = document.createElement('div');
                    portfolioDiv.className = 'portfolio-item border border-gray-200 rounded-lg p-3 shadow-sm';
                    portfolioDiv.innerHTML = `
                        <div class="portfolio-info mb-3">
                            <div class="portfolio-name font-semibold text-gray-700">${stock.name} (${symbol})${trendSymbol}</div>
                            <div class="portfolio-details text-sm text-gray-600 space-y-1 mt-1">
                                <div>Cantidad: ${portfolioItem.quantity}</div>
                                <div>Precio Prom.: $${formatCurrency(portfolioItem.avgPrice)}</div>
                                <div>Precio Actual: $${formatCurrency(stock.price)}</div>
                                <div>Valor Mercado: $${formatCurrency(marketValue)}</div>
                            </div>
                            <div class="portfolio-gainloss text-sm mt-2 ${gainLossClass}">
                                <span class="font-semibold">G/P:</span> $${formatCurrency(gainLoss)} (${formatCurrency(gainLossPercent)}%)
                            </div>
                        </div>
                        <div class="sl-tp-controls border-t border-gray-200 pt-3 mt-3 flex items-center justify-start space-x-6">
                            <div class="flex items-center space-x-2">
                                <label for="sl-toggle-${symbol}" class="sl-tp-label">SL (${stopLossThreshold}%)</label>
                                <div class="relative inline-block w-10 align-middle select-none transition duration-200 ease-in">
                                    <input type="checkbox" name="sl-toggle-${symbol}" id="sl-toggle-${symbol}" class="toggle-checkbox" ${portfolioItem.slActive ? 'checked' : ''} onchange="toggleStopLoss('${symbol}')"/>
                                    <label for="sl-toggle-${symbol}" class="toggle-label"></label>
                                </div>
                            </div>
                            <div class="flex items-center space-x-2">
                                <label for="tp-toggle-${symbol}" class="sl-tp-label">TP (+${takeProfitThreshold}%)</label>
                                <div class="relative inline-block w-10 align-middle select-none transition duration-200 ease-in">
                                    <input type="checkbox" name="tp-toggle-${symbol}" id="tp-toggle-${symbol}" class="toggle-checkbox" ${portfolioItem.tpActive ? 'checked' : ''} onchange="toggleTakeProfit('${symbol}')"/>
                                    <label for="tp-toggle-${symbol}" class="toggle-label"></label>
                                </div>
                            </div>
                        </div>
                        <div class="manual-sell-controls border-t border-gray-200 pt-3 mt-3 flex flex-col items-start space-y-2 md:flex-row md:items-center md:space-y-0 md:space-x-2">
                             <label for="sell-portfolio-qty-${symbol}" class="text-sm font-medium text-gray-700">Vender:</label>
                             <input type="number" id="sell-portfolio-qty-${symbol}" min="1" value="1" class="portfolio-qty-input w-full md:w-14">
                             <button onclick="sellFromPortfolio('${symbol}')" class="sell-button w-full md:w-auto">Vender</button>
                         </div>`;
                    portfolioEl.appendChild(portfolioDiv);
                });
            }
            // Update header values after iterating through portfolio
            portfolioValueEl.textContent = formatCurrency(currentPortfolioValue);
            totalValueEl.textContent = formatCurrency(cash + currentPortfolioValue);
        }


        function buyStock(symbol) {
            if (isPaused) { showMessage('El mercado está pausado. Reanuda para operar.', 'error'); return; }
            const quantityInput = document.getElementById(`buy-qty-${symbol}`);
            const quantity = parseInt(quantityInput.value);
            const stock = stocks.find(s => s.symbol === symbol);
            if (!stock || isNaN(quantity) || quantity <= 0) { showMessage('Cantidad inválida.', 'error'); quantityInput.focus(); return; }
            const cost = stock.price * quantity;
            if (cost > cash) { showMessage('No tienes suficiente dinero.', 'error'); return; }
            const buyPrice = stock.price;
            cash -= cost;
            if (portfolio[symbol]) {
                const existingQuantity = portfolio[symbol].quantity;
                const existingAvgPrice = portfolio[symbol].avgPrice;
                portfolio[symbol].avgPrice = ((existingAvgPrice * existingQuantity) + cost) / (existingQuantity + quantity);
                portfolio[symbol].quantity += quantity;
            } else { portfolio[symbol] = { quantity: quantity, avgPrice: buyPrice, slActive: false, tpActive: false }; }
            addTransaction('BUY', symbol, quantity, buyPrice);
            showMessage(`Compraste ${quantity} acciones de ${symbol} por $${formatCurrency(cost)}`, 'success');
            quantityInput.value = '1';
            updateGameInfo();
            renderPortfolio();
        }

        function sellFromPortfolio(symbol) {
             if (isPaused) { showMessage('El mercado está pausado. Reanuda para operar.', 'error'); return; }
             const inputId = `sell-portfolio-qty-${symbol}`;
             const quantityInput = document.getElementById(inputId);
             if (!quantityInput) { console.error(`Input not found: ${inputId}`); return; }
             const quantity = parseInt(quantityInput.value);
             const success = sellStock(symbol, quantity, false, ''); // Pass false for isAutoSell
             if (success || (!success && quantity > 0)) { quantityInput.value = '1'; } // Reset input only if sell happened or attempted
         }

        function sellStock(symbol, quantityToSell = 0, isAutoSell = false, triggerType = '') {
            if (!isAutoSell && isPaused) { showMessage('El mercado está pausado. Reanuda para operar.', 'error'); return false; }
            const stock = stocks.find(s => s.symbol === symbol);
            const quantity = quantityToSell; // Use the passed quantity
            if (!stock || isNaN(quantity) || quantity <= 0) { if (!isAutoSell) showMessage('Cantidad inválida.', 'error'); return false; }
            if (!portfolio[symbol] || portfolio[symbol].quantity < quantity) { if (!isAutoSell) showMessage(`No tienes suficientes acciones de ${symbol} para vender.`, 'error'); return false; }

            const sellPrice = stock.price;
            const avgPrice = portfolio[symbol].avgPrice;
            const revenue = sellPrice * quantity;
            cash += revenue;
            const soldQuantity = quantity; // Store the actual quantity sold
            portfolio[symbol].quantity -= quantity;

            let transactionType = 'SELL';
            let messageType = 'success';
            if (isAutoSell) {
                transactionType = triggerType; // SL or TP
                messageType = triggerType === 'SL' ? 'error' : 'success'; // SL is often seen negatively
            }

            addTransaction(transactionType, symbol, soldQuantity, sellPrice, avgPrice); // Log the transaction

            if (portfolio[symbol].quantity === 0) { delete portfolio[symbol]; } // Remove if empty

            // Display appropriate message
            if (isAutoSell) {
                if (triggerType === 'SL') showMessage(`¡STOP-LOSS (${stopLossThreshold}%) ACTIVADO! Vendidas ${soldQuantity} acciones de ${symbol} a $${formatCurrency(sellPrice)}.`, messageType);
                else if (triggerType === 'TP') showMessage(`¡TAKE-PROFIT (+${takeProfitThreshold}%) ACTIVADO! Vendidas ${soldQuantity} acciones de ${symbol} a $${formatCurrency(sellPrice)}.`, messageType);
                else showMessage(`¡Venta Automática! Vendidas ${soldQuantity} acciones de ${symbol} a $${formatCurrency(sellPrice)}.`, 'info'); // Fallback
            } else {
                showMessage(`Vendiste ${soldQuantity} acciones de ${symbol} por $${formatCurrency(revenue)}`, messageType);
            }

            updateGameInfo();
            renderPortfolio();
            return true; // Indicate success
        }


        function addTransaction(type, symbol, quantity, price, avgPrice = null) {
            // Solo añade si la cantidad es mayor que 0
            if (quantity > 0) {
                const transaction = { type: type, symbol: symbol, quantity: quantity, price: price, timestamp: new Date(), avgPrice: avgPrice };
                transactionHistory.push(transaction);
            } else {
                console.warn(`Intento de añadir transacción con cantidad 0 para ${symbol}`);
            }
        }


        function toggleStopLoss(symbol) {
            if (isPaused) {
                showMessage('El mercado está pausado. Reanuda para operar.', 'error');
                const cb = document.getElementById(`sl-toggle-${symbol}`);
                if(cb) cb.checked = !cb.checked; // Revert checkbox state
                return;
            }
            if (portfolio[symbol]) {
                portfolio[symbol].slActive = !portfolio[symbol].slActive;
                showMessage(`Stop-Loss (${stopLossThreshold}%) para ${symbol} ${portfolio[symbol].slActive ? 'ACTIVADO' : 'DESACTIVADO'}.`, 'info');
            }
        }

        function toggleTakeProfit(symbol) {
             if (isPaused) {
                 showMessage('El mercado está pausado. Reanuda para operar.', 'error');
                 const cb = document.getElementById(`tp-toggle-${symbol}`);
                 if(cb) cb.checked = !cb.checked; // Revert checkbox state
                 return;
             }
             if (portfolio[symbol]) {
                 portfolio[symbol].tpActive = !portfolio[symbol].tpActive;
                 showMessage(`Take-Profit (+${takeProfitThreshold}%) para ${symbol} ${portfolio[symbol].tpActive ? 'ACTIVADO' : 'DESACTIVADO'}.`, 'info');
             }
         }

        function checkAutoOrders() {
            const ordersToExecute = [];
            for (const symbol in portfolio) {
                const portfolioItem = portfolio[symbol];
                const stock = stocks.find(s => s.symbol === symbol);
                // Ensure stock exists, quantity > 0, and avgPrice is valid before checking
                if (!stock || !portfolioItem || portfolioItem.quantity <= 0 || portfolioItem.avgPrice <= 0) continue;

                const currentPrice = stock.price;
                const avgPrice = portfolioItem.avgPrice;
                const gainLossPercent = ((currentPrice - avgPrice) / avgPrice) * 100;

                // Check Stop Loss: Use <= for threshold
                if (portfolioItem.slActive && gainLossPercent <= stopLossThreshold) {
                    ordersToExecute.push({ symbol: symbol, type: 'SL' });
                    continue; // Execute SL and skip TP check for this stock in this tick
                }
                // Check Take Profit: Use >= for threshold
                if (portfolioItem.tpActive && gainLossPercent >= takeProfitThreshold) {
                    ordersToExecute.push({ symbol: symbol, type: 'TP' });
                }
            }
            // Execute collected orders after checking all stocks
            ordersToExecute.forEach(order => {
                // Double-check if the item still exists in portfolio before selling
                if (portfolio[order.symbol] && portfolio[order.symbol].quantity > 0) { // Added check for quantity > 0
                    const quantityToSell = portfolio[order.symbol].quantity; // Sell all remaining quantity
                    sellStock(order.symbol, quantityToSell, true, order.type);
                }
            });
        }


        // --- MODIFICADA: simulatePriceChange ---
        function simulatePriceChange() {
            stocks.forEach(stock => {
                stock.lastPrice = stock.price; // Store previous price

                let effectiveVolatility = stock.volatility;
                let effectiveTrend = stock.trend; // Start with base trend
                let eventIsInfluencing = false; // Flag to see if any active event affects this stock's trend

                // Apply active event modifiers
                activeEvents.forEach(activeEvent => {
                    // Check if the event applies to this stock
                    if (activeEvent.event.target === 'ALL' || activeEvent.event.target === stock.symbol) {
                        // Apply modifier only if event is not new OR if it's the first tick the event is active
                         if (!activeEvent.isNew || (activeEvent.isNew && activeEvent.remainingTicks === activeEvent.event.duration)) {
                            effectiveVolatility *= activeEvent.event.volatility_modifier;
                            effectiveTrend += activeEvent.event.trend_modifier;
                            // Mark that an event is influencing the trend calculation if its modifier is non-zero
                            if (activeEvent.event.trend_modifier !== 0) {
                                eventIsInfluencing = true;
                            }
                        }
                    }
                });

                // Cap effective trend
                effectiveTrend = Math.max(MIN_TREND * 2, Math.min(effectiveTrend, MAX_TREND * 2));

                // Calculate initial price change based on potentially modified trend and volatility
                const randomFactor = (Math.random() - 0.5) * 2; // -1 to 1
                let priceChangePercent = randomFactor * effectiveVolatility + effectiveTrend;

                // --- LÓGICA DE GARANTÍA DE DIRECCIÓN CON MAYOR IMPACTO ---
                if (eventIsInfluencing) {
                    // Check if the net effect of events intended a positive trend (effective > base)
                    if (effectiveTrend > stock.trend) {
                        // If positive news resulted in a negative change, force it positive
                        if (priceChangePercent < 0) {
                            const addedTrend = Math.max(0.00001, effectiveTrend - stock.trend); // Ensure addedTrend is positive
                            // Force a positive change, scaled between 50% and 200% of the added trend
                            priceChangePercent = (Math.random() * 1.5 + 0.5) * addedTrend; // <-- AJUSTE DE ESCALA
                            // console.log(`Forced POSITIVE change for ${stock.symbol}: ${priceChangePercent}`);
                        }
                    }
                    // Check if the net effect of events intended a negative trend (effective < base)
                    else if (effectiveTrend < stock.trend) {
                        // If negative news resulted in a positive change, force it negative
                        if (priceChangePercent > 0) {
                            const addedTrend = Math.min(-0.00001, effectiveTrend - stock.trend); // Ensure addedTrend is negative
                             // Force a negative change, scaled between 50% and 200% of the added trend
                            priceChangePercent = (Math.random() * 1.5 + 0.5) * addedTrend; // <-- AJUSTE DE ESCALA
                            // console.log(`Forced NEGATIVE change for ${stock.symbol}: ${priceChangePercent}`);
                        }
                    }
                }
                // --- FIN LÓGICA DE GARANTÍA ---

                // Calculate the new price using the (potentially adjusted) priceChangePercent
                let newPrice = stock.price * (1 + priceChangePercent);
                newPrice = Math.max(0.01, newPrice); // Prevent price from going below 0.01

                stock.price = newPrice;

                // Update history for chart
                stock.history.push({ tick: tickCounter, price: stock.price });
                if (stock.history.length > maxHistoryLength) {
                    stock.history.shift();
                }
            });
        }


        function updateStockTrends() {
             stocks.forEach(stock => {
                 const changeDirection = Math.random() < 0.5 ? -1 : 1;
                 let newTrend = stock.trend + changeDirection * TREND_CHANGE_AMOUNT;
                 newTrend = Math.max(MIN_TREND, Math.min(newTrend, MAX_TREND));
                 stock.trend = newTrend;
             });
         }

        function manageEvents() {
             // Decrease remaining ticks and remove expired events FIRST
             activeEvents = activeEvents.filter(activeEvent => {
                 activeEvent.remainingTicks--;
                 if (activeEvent.remainingTicks <= 0) {
                     console.log(`Event ended: ${activeEvent.event.name}`);
                     return false;
                 }
                 return true;
             });

             // Mark events that were new as no longer new AFTER applying effects
             activeEvents.forEach(ae => { if(ae.isNew) ae.isNew = false; });


             // Try to trigger a new event
             if (activeEvents.length < MAX_ACTIVE_EVENTS && Math.random() < EVENT_PROBABILITY) {
                 const availableEvents = marketEvents.filter(event => !activeEvents.some(ae => ae.event.name === event.name));
                 if (availableEvents.length > 0) {
                     const newEvent = availableEvents[Math.floor(Math.random() * availableEvents.length)];
                     activeEvents.push({ event: newEvent, remainingTicks: newEvent.duration, isNew: true });
                     console.log(`New event triggered: ${newEvent.name} (Duration: ${newEvent.duration} ticks)`);
                     showEventNotification(`📰 ${newEvent.message}`);
                 }
             }
         }


        function initializeChart() {
            const ctx = chartCanvas.getContext('2d');
            stockChart = new Chart(ctx, {
                type: 'line',
                data: { labels: [], datasets: [] },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    scales: {
                        y: { beginAtZero: false, ticks: { callback: value => '$' + formatCurrency(value) } },
                        x: { ticks: { display: false }, grid: { display: false } }
                    },
                    plugins: {
                        legend: { position: 'top' },
                        tooltip: {
                            mode: 'index', intersect: false,
                            callbacks: { label: context => `${context.dataset.label || ''}: $${formatCurrency(context.parsed.y)}` }
                        }
                    },
                    animation: { duration: 200 }
                }
            });
            updateChart();
        }

        function updateChart() {
             if (!stockChart) return;

             const visibleStocks = stocks.filter(stock => stock.showOnChart);
             let labels = [];

             // Determine labels based on the longest history among visible stocks or tickCounter
             let maxHistoryLengthFound = 0;
             if (visibleStocks.length > 0) {
                 visibleStocks.forEach(stock => {
                     if (stock.history && Array.isArray(stock.history) && stock.history.length > maxHistoryLengthFound) {
                         maxHistoryLengthFound = stock.history.length;
                         labels = stock.history.map(h => h.tick);
                     }
                 });
             }
             // Fallback if no visible stocks or they have no history yet
             if (labels.length === 0 && tickCounter >= 0) {
                 const startTick = Math.max(0, tickCounter - maxHistoryLength + 1);
                 labels = [];
                 for (let i = startTick; i <= tickCounter; i++) labels.push(i);
             }
             // Ensure labels don't exceed maxHistoryLength visually
             if (labels.length > maxHistoryLength) {
                 labels = labels.slice(-maxHistoryLength);
             }


             stockChart.data.labels = labels;
             stockChart.data.datasets = visibleStocks.map(stock => {
                 // Get history data corresponding to the labels
                 const historyData = labels.map(tick => {
                     const historyPoint = stock.history?.find(h => h.tick === tick);
                     return historyPoint ? historyPoint.price : null;
                 });

                 return {
                     label: stock.symbol,
                     data: historyData,
                     borderColor: stock.color,
                     backgroundColor: stock.color + '33',
                     tension: 0.1,
                     pointRadius: 0,
                     pointHoverRadius: 5
                 };
             });

             stockChart.update();
         }


        function toggleChartVisibility(symbol) {
            const stock = stocks.find(s => s.symbol === symbol);
            if (stock) {
                stock.showOnChart = !stock.showOnChart;
                updateChart();
            }
        }

        // --- MODIFICADA: updateMarket ---
        function updateMarket() {
            if (isPaused) return;

            tickCounter++;
            manageEvents(); // Decide if new events start/end THIS tick
            simulatePriceChange(); // Calculate new prices USING current active events (NOW WITH GUARANTEED DIRECTION & IMPACT)
            renderStockMarket(); // Update market list UI
            renderPortfolio(); // Update portfolio UI
            checkAutoOrders(); // Execute SL/TP orders based on new prices
            updateChart(); // Update the chart with new prices

            // --- NUEVO: Autoguardado ---
            saveGameState(); // Guarda el estado después de cada actualización completa
        }

        function setPauseState(shouldPause) {
             isPaused = shouldPause;
             if (isPaused) {
                 if (gameInterval) { clearInterval(gameInterval); gameInterval = null; }
                 pauseResumeBtn.textContent = 'Reanudar';
                 pauseResumeBtn.classList.remove('pause-button', 'bg-blue-600', 'hover:bg-blue-700', 'focus:ring-blue-500');
                 pauseResumeBtn.classList.add('resume-button', 'bg-red-600', 'hover:bg-red-700', 'focus:ring-red-500');
                 showMessage('Mercado pausado. Haz clic en Reanudar para continuar.', 'info');
             } else {
                 if (!gameInterval) {
                     updateMarket(); // Run first update immediately on resume
                     gameInterval = setInterval(updateMarket, updateInterval);
                 }
                 pauseResumeBtn.textContent = 'Pausar';
                 pauseResumeBtn.classList.remove('resume-button', 'bg-red-600', 'hover:bg-red-700', 'focus:ring-red-500');
                 pauseResumeBtn.classList.add('pause-button', 'bg-blue-600', 'hover:bg-blue-700', 'focus:ring-blue-500');
                 showMessage('Mercado reanudado.', 'info');
             }
         }

        function togglePause() {
            setPauseState(!isPaused);
        }


        function showHistory() {
             historyListEl.innerHTML = '';
             // Usa la variable global transactionHistory que ahora se reinicia al cargar
             if (transactionHistory.length === 0) {
                 historyListEl.innerHTML = '<li class="text-gray-500">No hay transacciones todavía en esta sesión.</li>';
             } else {
                 [...transactionHistory].sort((a, b) => b.timestamp - a.timestamp).forEach(tx => {
                     const li = document.createElement('li');
                     li.className = 'history-list-item';
                     const timestamp = (tx.timestamp instanceof Date) ? tx.timestamp : new Date(tx.timestamp);
                     const stockInfo = stocks.find(s => s.symbol === tx.symbol);
                     const stockName = stockInfo ? stockInfo.name : tx.symbol;

                     let gainLossHTML = '';
                     if (['SELL', 'SL', 'TP'].includes(tx.type) && tx.avgPrice !== null && tx.avgPrice > 0) {
                         const realizedGainLoss = (tx.price - tx.avgPrice) * tx.quantity;
                         const gainLossClass = realizedGainLoss >= 0 ? 'price-up' : 'price-down';
                         gainLossHTML = `<div class="history-gain-loss ${gainLossClass}">Ganancia/Pérdida: $${formatCurrency(realizedGainLoss)}</div>`;
                     }

                     li.innerHTML = `
                         <div class="history-main-line">
                             <span class="history-type-${tx.type}">${tx.type}</span>
                             <span>${stockName}:</span>
                             <span>${tx.quantity} acc.</span>
                             <span>@ $${formatCurrency(tx.price)}</span>
                             <span class="text-gray-500 text-xs float-right">${formatTimestamp(timestamp)}</span>
                         </div>
                         ${gainLossHTML}`;
                     historyListEl.appendChild(li);
                 });
             }
             historyModal.classList.remove('hidden');
         }


        function closeHistory() { historyModal.classList.add('hidden'); }

        function getCurrentGlobalBalance() {
            try {
                const savedBalance = localStorage.getItem(BALANCE_LOCAL_STORAGE_KEY);
                if (savedBalance !== null) { const parsedBalance = parseInt(savedBalance); if (!isNaN(parsedBalance)) { return parsedBalance; } }
            } catch (error) { console.error("Error al leer el saldo global desde localStorage:", error); }
            return DEFAULT_BALANCE;
        }

        function saveGlobalBalance(newBalance) {
             try {
                 const balanceToSave = Math.round(newBalance);
                 if (isNaN(balanceToSave)) { console.error("Intento de guardar un saldo global inválido (NaN)."); return; }
                 localStorage.setItem(BALANCE_LOCAL_STORAGE_KEY, balanceToSave.toString());
                 console.log(`Nuevo saldo global guardado: ${balanceToSave}`);
             } catch (error) { console.error("Error al guardar el saldo global en localStorage:", error); showMessage("Error al actualizar el saldo global.", "error"); }
         }

        // --- MODIFICADA: saveGameState ---
        function saveGameState() {
            try {
                const gameState = {
                    cash: cash, // <-- AÑADIDO: Guardar cash actual
                    stocks: stocks.map(s => ({
                        symbol: s.symbol, name: s.name, price: s.price, lastPrice: s.lastPrice,
                        volatility: s.volatility, trend: s.trend, color: s.color,
                        showOnChart: s.showOnChart, history: s.history
                    })),
                    portfolio: portfolio,
                    // transactionHistory: transactionHistory, // <-- No guardar historial
                    tickCounter: tickCounter,
                    activeEvents: activeEvents,
                    showTrendIndicator: showTrendIndicator,
                };
                sessionStorage.setItem(STOCK_GAME_STATE_KEY, JSON.stringify(gameState));
                // console.log("Estado del juego guardado en sessionStorage."); // Log opcional para autoguardado
            } catch (error) {
                console.error("Error al guardar el estado del juego en sessionStorage:", error);
                // No mostrar mensaje al usuario para no ser intrusivo con el autoguardado
                // showMessage("Error al guardar el progreso del juego.", "error");
            }
        }

        // --- MODIFICADA: loadGameState ---
        function loadGameState() {
            let loadedFromSave = false;
            try {
                // 1. Leer Inversión Inicial (para cálculo G/P al salir)
                const initialInvestmentStr = sessionStorage.getItem(GAME6_INVESTMENT_SESSION_KEY);
                let parsedInvestment = 10000; // Default
                if (initialInvestmentStr) {
                    const tempInvestment = parseInt(initialInvestmentStr);
                    if (!isNaN(tempInvestment) && tempInvestment > 0) {
                        parsedInvestment = tempInvestment;
                    } else { console.warn("Inversión inicial inválida en sessionStorage. Usando 10,000."); }
                } else { console.warn("No se encontró inversión inicial en sessionStorage. Usando 10,000."); }
                initialInvestment = parsedInvestment; // Guardar para cálculo G/P al salir

                // 2. Intentar cargar el estado guardado del juego
                const savedStateStr = sessionStorage.getItem(STOCK_GAME_STATE_KEY);
                if (savedStateStr) {
                    console.log("Cargando estado del juego desde sessionStorage...");
                    const savedState = JSON.parse(savedStateStr);
                    // --- RESTAURAR ESTADO ---
                    cash = savedState.cash !== undefined ? savedState.cash : initialInvestment; // <-- Restaurar cash guardado
                    stocks = savedState.stocks.map(s => ({
                         ...s,
                         lastPrice: s.lastPrice !== undefined ? s.lastPrice : s.price,
                         history: Array.isArray(s.history) ? s.history : [{ tick: 0, price: s.price }]
                     }));
                    portfolio = savedState.portfolio || {};
                    transactionHistory = []; // Siempre empezar con historial vacío
                    tickCounter = savedState.tickCounter || 0;
                    activeEvents = (savedState.activeEvents || []).map(ae => ({...ae, isNew: false}));
                    showTrendIndicator = savedState.showTrendIndicator || false;
                    isPaused = true; // Empezar pausado si se carga
                    loadedFromSave = true;
                    showMessage(`Partida anterior cargada. Dinero: $${formatCurrency(cash)}. Mercado pausado. Historial reiniciado.`, "info");
                } else {
                     // --- INICIAR NUEVA PARTIDA ---
                    console.log("No se encontró estado guardado. Iniciando nueva partida.");
                    cash = initialInvestment; // <-- Usar inversión inicial para cash
                    stocks = initialStockData.map(initialStock => ({
                        ...initialStock, lastPrice: initialStock.price,
                        history: [{ tick: 0, price: initialStock.price }],
                        showOnChart: initialStock.showOnChart !== undefined ? initialStock.showOnChart : true,
                        trend: initialStock.trend
                    }));
                    portfolio = {};
                    transactionHistory = []; // Empezar con historial vacío
                    tickCounter = 0;
                    activeEvents = []; showTrendIndicator = false; isPaused = false; // No empezar pausado si es nuevo
                    showMessage(`Inversión inicial: $${formatCurrency(cash)}. ¡Bienvenido! El mercado se actualiza cada ${updateInterval / 1000} segundos.`, "info");
                }
            } catch (error) {
                // --- FALLBACK EN CASO DE ERROR ---
                console.error("Error al cargar el estado del juego:", error);
                cash = initialInvestment > 0 ? initialInvestment : 10000; // Usar inversión leída o default
                stocks = initialStockData.map(initialStock => ({ ...initialStock, lastPrice: initialStock.price, history: [{ tick: 0, price: initialStock.price }] }));
                portfolio = {}; transactionHistory = []; tickCounter = 0;
                activeEvents = []; isPaused = false; showTrendIndicator = false;
                showMessage("Error al cargar datos. Iniciando nueva partida.", "error");
            }
            return loadedFromSave;
        }

        function initializeGame() {
            const loadedFromSave = loadGameState();
            buildStockMarketList();
            renderPortfolio();
            updateGameInfo();
            initializeChart();
            setPauseState(isPaused); // Set initial pause state based on load

            const cashDisplayElement = document.getElementById('cash');
            if (cashDisplayElement) {
                cashDisplayElement.addEventListener('dblclick', () => {
                    showTrendIndicator = !showTrendIndicator;
                    console.log(`Trend indicator ${showTrendIndicator ? 'ACTIVATED' : 'DEACTIVATED'}`);
                    renderPortfolio();
                    showMessage(`Indicador de tendencia ${showTrendIndicator ? 'activado' : 'desactivado'}.`, 'info');
                });
            } else { console.error("Elemento #cash no encontrado para añadir listener de doble clic."); }
        }

        function handleExitClick(event) {
            event.preventDefault();
            console.log("Botón Menú presionado. Guardando estado y actualizando saldo global...");
            if (!isPaused) { setPauseState(true); } // Pause if running
            saveGameState(); // Save current state (con cash, sin historial)
            try {
                const finalPortfolioValue = calculatePortfolioValue();
                const finalTotalValue = cash + finalPortfolioValue;
                // Usar la variable 'initialInvestment' guardada al inicio de la sesión
                const netGainLoss = finalTotalValue - initialInvestment;
                console.log(`Inversión Inicial (esta sesión): ${formatCurrency(initialInvestment)}`);
                console.log(`Valor Total Final: ${formatCurrency(finalTotalValue)} (Cash: ${formatCurrency(cash)}, Cartera: ${formatCurrency(finalPortfolioValue)})`);
                console.log(`Ganancia/Pérdida Neta (esta sesión): ${formatCurrency(netGainLoss)}`);
                const currentGlobalBalance = getCurrentGlobalBalance();
                console.log(`Saldo Global Actual (antes): ${formatCurrency(currentGlobalBalance)}`);
                const newGlobalBalance = currentGlobalBalance + netGainLoss;
                console.log(`Nuevo Saldo Global Calculado: ${formatCurrency(newGlobalBalance)}`);
                saveGlobalBalance(newGlobalBalance);
                console.log(`Saldo global actualizado. Estado del juego guardado.`);
            } catch (error) {
                console.error("Error durante el proceso de actualización del saldo global al salir:", error);
                showMessage("Ocurrió un error al actualizar tu saldo global. Los cambios podrían no guardarse.", "error");
            }
            console.log("Redirigiendo a:", event.target.href);
            window.location.href = event.target.href;
        }

        // --- Event Listeners ---
        pauseResumeBtn.addEventListener('click', togglePause);
        historyModal.addEventListener('click', (event) => { if (event.target === historyModal) { closeHistory(); } });
        exitButton.addEventListener('click', handleExitClick);

        // Iniciar el juego
        window.onload = initializeGame;

    </script>
</body>
</ht