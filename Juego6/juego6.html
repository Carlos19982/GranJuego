<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Bolsa - Estado Persistente</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* Estilos generales (sin cambios) */
        body { background-color: #f3f4f6; font-family: 'Inter', sans-serif; }
        .price-up { color: #10b981; }
        .price-down { color: #ef4444; }
        input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        input[type=number] { -moz-appearance: textfield; }
        .action-button { @apply px-3 py-1 text-xs font-medium text-white rounded shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2; }
        .buy-button { @apply bg-emerald-600 hover:bg-emerald-700 focus:ring-emerald-500 action-button; }
        .sell-button { @apply bg-rose-600 hover:bg-rose-700 focus:ring-rose-500 action-button; }
        .control-button { @apply px-4 py-2 font-semibold text-white rounded shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 transition duration-150 ease-in-out; }
        .pause-button { @apply bg-blue-600 hover:bg-blue-700 focus:ring-blue-500 control-button; }
        .resume-button { @apply bg-red-600 hover:bg-red-700 focus:ring-red-500 control-button; }
        .history-button { @apply bg-gray-600 hover:bg-gray-700 focus:ring-gray-500 control-button; }
        .chart-container { height: 300px; position: relative; margin-top: 1.5rem; }
        .toggle-checkbox:checked { right: 0; border-color: #68D391; }
        .toggle-checkbox:checked + .toggle-label { background-color: #68D391; }
        .toggle-checkbox { @apply absolute block w-4 h-4 mt-1 ml-1 rounded-full bg-white border-2 appearance-none cursor-pointer; transition: right 0.2s ease-in-out; }
        .toggle-label { @apply block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer; width: 40px; transition: background-color 0.2s ease-in-out; }
        .sl-tp-label { @apply text-xs font-medium text-gray-600; }
        /* Estilos Modal Historial (sin cambios) */
        .modal { @apply fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50 flex items-center justify-center; }
        .modal-content { @apply relative mx-auto p-5 border w-full max-w-2xl shadow-lg rounded-md bg-white; }
        .modal-close { @apply absolute top-0 right-0 cursor-pointer p-4 text-xl font-bold text-gray-700 hover:text-red-500; }
        .history-list-item { @apply border-b border-gray-200 py-3 text-sm; }
        .history-main-line span { @apply mr-2; }
        .history-gain-loss { @apply text-xs pl-4; }
        .history-type-BUY { @apply font-semibold text-green-600; }
        .history-type-SELL { @apply font-semibold text-red-600; }
        .history-type-SL { @apply font-semibold text-red-800; }
        .history-type-TP { @apply font-semibold text-green-800; }
        /* Estilo para inputs peque√±os (sin cambios) */
        .portfolio-qty-input { @apply px-2 py-1 border border-gray-300 rounded text-sm text-center focus:ring-1 focus:ring-blue-500 focus:border-blue-500; }
         /* Estilo para el bot√≥n de men√∫ (sin cambios) */
        .menu-link-button { @apply inline-block bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-150 ease-in-out text-sm no-underline focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500; }
        /* Style for cash element to indicate interactivity (sin cambios) */
        #cash { cursor: pointer; user-select: none; -webkit-user-select: none; }
        /* Styles for the new event notification banner (sin cambios) */
        #event-notification-banner {
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
            opacity: 0;
            transform: translateY(-100%);
            pointer-events: none;
        }
        #event-notification-banner.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto; /* Allow interaction when visible */
        }

    </style>
     <link rel="preconnect" href="https://rsms.me/">
     <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
     <style> body { font-family: 'Inter var', sans-serif; } </style> 
</head>
<body class="min-h-screen">

    <div id="event-notification-banner" class="fixed top-4 left-1/2 -translate-x-1/2 z-[1000] px-6 py-3 rounded-lg shadow-lg text-white text-sm font-semibold bg-indigo-600 hidden">
        </div>

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        <header class="mb-8 p-4 bg-white rounded-lg shadow-md">
             <h1 class="text-2xl md:text-3xl font-bold text-gray-800 text-center mb-4">Simulador de Bolsa</h1>
             <div class="flex flex-wrap justify-around text-center text-sm md:text-base text-gray-700">
                 <div class="info-item mx-2 my-1"><span class="font-semibold">Dinero:</span> $<span id="cash">Cargando...</span></div>
                 <div class="info-item mx-2 my-1"><span class="font-semibold">Valor Cartera:</span> $<span id="portfolio-value">0,00</span></div>
                 <div class="info-item mx-2 my-1"><span class="font-semibold">Valor Total:</span> $<span id="total-value">Cargando...</span></div>
             </div>
          </header>

        <main class="grid grid-cols-1 md:grid-cols-2 gap-6 md:gap-8 mb-8">
            <section id="market-chart-section" class="bg-white p-4 md:p-6 rounded-lg shadow-md">
                <h2 class="text-xl md:text-2xl font-semibold text-gray-800 mb-4">Mercado de Acciones</h2>
                <div class="chart-container mb-6">
                    <canvas id="stockChart"></canvas>
                </div>
            </section>

             <section id="portfolio-section" class="bg-white p-4 md:p-6 rounded-lg shadow-md">
                <h2 class="text-xl md:text-2xl font-semibold text-gray-800 mb-4">Mi Cartera</h2>
                <div id="portfolio" class="space-y-4">
                    <p id="empty-portfolio-msg" class="text-gray-500">A√∫n no tienes acciones.</p>
                </div>
             </section>

             <section id="market-list-section" class="bg-white p-4 md:p-6 rounded-lg shadow-md md:col-span-2">
                <h3 class="text-lg font-semibold text-gray-700 mb-3">Acciones Disponibles</h3>
                <div id="stock-market" class="space-y-4">
                    <p class="text-gray-500">Cargando mercado...</p>
                </div>
             </section>
        </main>

        <footer class="text-center space-y-4 pb-8">
             <div id="message-box" class="p-3 bg-gray-100 border border-gray-300 rounded-md text-gray-700 min-h-[40px] text-sm md:text-base">
                 Cargando simulador...
             </div>
             <div class="controls flex justify-center space-x-4">
                 <button id="pause-resume-btn" class="pause-button">Pausar</button>
                 <button id="history-btn" onclick="showHistory()" class="history-button">Mostrar Historial</button>
             </div>
             <div class="mt-4">
                 <a href="../index.html" id="exit-button" class="menu-link-button">
                     ‚Üê Men√∫
                 </a>
             </div>
        </footer>

         <div id="history-modal" class="modal hidden">
             <div class="modal-content">
                 <span class="modal-close" onclick="closeHistory()">√ó</span>
                 <h3 class="text-xl font-semibold mb-4 text-gray-800">Historial de Transacciones</h3>
                 <div class="max-h-96 overflow-y-auto">
                     <ul id="history-list">
                         <li class="text-gray-500">No hay transacciones todav√≠a.</li>
                     </ul>
                 </div>
             </div>
          </div>

    </div>

    <script>
        // --- Constantes de Storage ---
        const BALANCE_LOCAL_STORAGE_KEY = 'cardGamePlayerBalance_v3';
        const GAME6_INVESTMENT_SESSION_KEY = 'game6InitialInvestment';
        const STOCK_GAME_STATE_KEY = 'stockSimGameState_v2';
        const DEFAULT_BALANCE = 5000;

        // --- Configuraci√≥n Inicial ---
        let cash = 10000; // Ser√° sobrescrito al cargar
        let portfolio = {};
        const initialStockData = [
            { symbol: 'TECH', name: 'Tech Corp üíª', price: 150.00, volatility: 0.032, trend: 0.00002, color: '#3B82F6', showOnChart: true },
            { symbol: 'FOOD', name: 'Foodies Inc üçî', price: 50.00, volatility: 0.016, trend: 0.00001, color: '#F59E0B', showOnChart: true },
            { symbol: 'GAME', name: 'GameDev Co üéÆ', price: 80.00, volatility: 0.048, trend: -0.00001, color: '#8B5CF6', showOnChart: true },
            { symbol: 'FIN', name: 'Finance Hub üí∞', price: 200.00, volatility: 0.024, trend: 0.000015, color: '#10B981', showOnChart: true },
            { symbol: 'ECO', name: 'Eco Energy üåø', price: 70.00, volatility: 0.040, trend: 0.00003, color: '#6B7280', showOnChart: true }
        ];
        let stocks = [];
        let transactionHistory = []; 
        const stopLossThreshold = -4.0;
        const takeProfitThreshold = 5.0;
        let gameInterval = null;
        let isPaused = false;
        const updateInterval = 10000;
        const maxHistoryLength = 60;
        let tickCounter = 0;
        let initialInvestment = 0;

        // Constantes para Tendencia Din√°mica
        const TREND_UPDATE_TICKS = 5;
        const TREND_CHANGE_AMOUNT = 0.000025;
        const MAX_TREND = 0.00015;
        const MIN_TREND = -0.00015;

        // Variable para el atajo secreto
        let showTrendIndicator = false;

        // Event System Variables & Config
        const EVENT_PROBABILITY = 0.25;
        const MAX_ACTIVE_EVENTS = 2;
        let activeEvents = [];
        
        // --- Lista de Eventos Ambiguos y Enga√±osos ---
        const marketEvents = [
             { name: "Optimismo Global Cauteloso", message: "üì∞ El mercado muestra optimismo, pero los analistas piden cautela. ¬øOportunidad o trampa?", target: 'ALL', duration: 3, volatility_modifier: 2.5, trend_modifier: -0.00005 },
             { name: "Temor a Recesi√≥n", message: "üì∞ Aumentan los temores de recesi√≥n, pero algunos ven oportunidades de compra.", target: 'ALL', duration: 3, volatility_modifier: 2.8, trend_modifier: 0.00006 },
             { name: "Anuncio Tecnol√≥gico", message: "üì∞ Tech Corp har√° un 'anuncio importante' esta semana. El mercado especula.", target: 'TECH', duration: 3, volatility_modifier: 3.0, trend_modifier: 0.0003 },
             { name: "Regulaci√≥n Tecnol√≥gica", message: "üì∞ Se anuncian nuevas regulaciones para el sector Tech. ¬øProteger√°n al consumidor o ahogar√°n la innovaci√≥n?", target: 'TECH', duration: 3, volatility_modifier: 2.9, trend_modifier: -0.00015 },
             { name: "Movimientos en la Banca", message: "üì∞ Finance Hub reporta 'movimientos inesperados' en sus cuentas. ¬øBueno o malo?", target: 'FIN', duration: 3, volatility_modifier: 2.5, trend_modifier: 0.00015 },
             { name: "Ca√≠da del Petr√≥leo", message: "üì∞ El petr√≥leo se desploma. Malo para las petroleras, ¬øpero bueno para los costes de Eco Energy?", target: 'ECO', duration: 3, volatility_modifier: 3.1, trend_modifier: 0.00018 },
             { name: "Nuevo Proyecto de GameDev", message: "üì∞ GameDev Co. anuncia un proyecto secreto llamado 'Prometeo'. La comunidad est√° dividida.", target: 'GAME', duration: 3, volatility_modifier: 3.5, trend_modifier: 0.0004 },
             { name: "Cadena de Suministro", message: "üì∞ Foodies Inc reestructura su cadena de suministro. ¬øReducci√≥n de costes o se√±al de problemas?", target: 'FOOD', duration: 3, volatility_modifier: 2.8, trend_modifier: -0.00009 },
             { name: "Datos de Inflaci√≥n", message: "üìä ¬°Datos de inflaci√≥n generan alta incertidumbre y volatilidad!", target: 'ALL', duration: 3, volatility_modifier: 2.7, trend_modifier: -0.00003 },
             { name: "Desastre Natural", message: "üå™Ô∏è ¬°Desastre natural impacta la econom√≠a global!", target: 'ALL', duration: 3, volatility_modifier: 2.9, trend_modifier: -0.00010 },
        ];
        let eventNotificationTimeout = null;

        // --- Elementos del DOM ---
        const cashEl = document.getElementById('cash');
        const portfolioValueEl = document.getElementById('portfolio-value');
        const totalValueEl = document.getElementById('total-value');
        const stockMarketEl = document.getElementById('stock-market');
        const portfolioEl = document.getElementById('portfolio');
        const emptyPortfolioMsgEl = document.getElementById('empty-portfolio-msg');
        const pauseResumeBtn = document.getElementById('pause-resume-btn');
        const messageBoxEl = document.getElementById('message-box');
        const chartCanvas = document.getElementById('stockChart');
        const historyModal = document.getElementById('history-modal');
        const historyListEl = document.getElementById('history-list');
        const exitButton = document.getElementById('exit-button');
        const eventNotificationBanner = document.getElementById('event-notification-banner');
        let stockChart = null;

        // --- Funciones del Juego ---
        function showMessage(msg, type = 'info') {
            messageBoxEl.textContent = msg;
            messageBoxEl.className = 'p-3 border rounded-md min-h-[40px] text-sm md:text-base';
            switch (type) {
                case 'error': messageBoxEl.classList.add('bg-red-100', 'border-red-400', 'text-red-700'); break;
                case 'success': messageBoxEl.classList.add('bg-green-100', 'border-green-400', 'text-green-700'); break;
                case 'info': default: messageBoxEl.classList.add('bg-yellow-100', 'border-yellow-400', 'text-yellow-700'); break;
            }
        }

        function showEventNotification(msg) {
             if (!eventNotificationBanner) return;
             eventNotificationBanner.textContent = msg;
             eventNotificationBanner.classList.remove('hidden');
             void eventNotificationBanner.offsetWidth;
             eventNotificationBanner.classList.add('visible');
             if (eventNotificationTimeout) { clearTimeout(eventNotificationTimeout); }
             eventNotificationTimeout = setTimeout(() => {
                 eventNotificationBanner.classList.remove('visible');
                 setTimeout(() => { if (!eventNotificationBanner.classList.contains('visible')) { eventNotificationBanner.classList.add('hidden'); } }, 500);
                 eventNotificationTimeout = null;
             }, 15000);
         }

        function formatCurrency(amount) {
            if (typeof amount !== 'number' || isNaN(amount)) { return '0,00'; }
            return amount.toLocaleString('es-ES', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        }

        function formatTimestamp(date) {
            if (!(date instanceof Date) || isNaN(date.getTime())) return 'Fecha inv√°lida';
            return date.toLocaleString('es-ES', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit' });
        }

        function updateGameInfo() {
            cashEl.textContent = formatCurrency(cash);
            const currentPortfolioValue = calculatePortfolioValue();
            portfolioValueEl.textContent = formatCurrency(currentPortfolioValue);
            totalValueEl.textContent = formatCurrency(cash + currentPortfolioValue);
        }

        function buildStockMarketList() {
            stockMarketEl.innerHTML = '';
            if (stocks.length === 0) { stockMarketEl.innerHTML = '<p class="text-gray-500">No hay acciones disponibles.</p>'; return; }
            stocks.forEach(stock => {
                const stockDiv = document.createElement('div');
                stockDiv.id = `stock-item-${stock.symbol}`;
                stockDiv.className = 'stock-item border border-gray-200 rounded-lg p-3 shadow-sm flex flex-wrap justify-between items-center';
                stockDiv.innerHTML = `
                    <div class="flex-grow flex items-center mb-2 md:mb-0 mr-4">
                        <div class="relative inline-block w-10 mr-3 align-middle select-none transition duration-200 ease-in">
                            <input type="checkbox" name="toggle-${stock.symbol}" id="toggle-${stock.symbol}" class="toggle-checkbox" ${stock.showOnChart ? 'checked' : ''} onchange="toggleChartVisibility('${stock.symbol}')"/>
                            <label for="toggle-${stock.symbol}" class="toggle-label"></label>
                        </div>
                        <div class="stock-info">
                            <div class="stock-name font-semibold text-gray-700">${stock.name} (${stock.symbol})</div>
                            <div class="stock-price text-sm text-gray-600">
                                Precio: <span id="price-value-${stock.symbol}">$${formatCurrency(stock.price)}</span>
                                <span class="price-change-indicator font-bold ml-2" id="change-indicator-${stock.symbol}"></span>
                            </div>
                        </div>
                    </div>
                    <div class="actions flex items-center space-x-2 mt-2 md:mt-0 w-full md:w-auto justify-end">
                        <input type="number" id="buy-qty-${stock.symbol}" min="1" value="1" class="portfolio-qty-input w-16">
                        <button onclick="buyStock('${stock.symbol}')" class="buy-button">Comprar</button>
                    </div>`;
                stockMarketEl.appendChild(stockDiv);
                updateStockItemDisplay(stock);
            });
        }

        function updateStockItemDisplay(stock) {
             const priceValueEl = document.getElementById(`price-value-${stock.symbol}`);
             const changeIndicatorEl = document.getElementById(`change-indicator-${stock.symbol}`);
             if (!priceValueEl || !changeIndicatorEl) return;
             const priceChange = (stock.lastPrice !== undefined && stock.lastPrice !== null) ? stock.price - stock.lastPrice : 0;
             const changeIndicatorSymbol = priceChange > 0 ? '‚ñ≤' : (priceChange < 0 ? '‚ñº' : '');
             const changeClass = priceChange > 0 ? 'price-up' : (priceChange < 0 ? 'price-down' : 'text-gray-500');
             priceValueEl.textContent = `$${formatCurrency(stock.price)}`;
             changeIndicatorEl.textContent = `${changeIndicatorSymbol} ${formatCurrency(Math.abs(priceChange))}`;
             changeIndicatorEl.className = `price-change-indicator font-bold ml-2 ${changeClass}`;
         }

        function renderStockMarket() {
            stocks.forEach(stock => { if (document.getElementById(`stock-item-${stock.symbol}`)) { updateStockItemDisplay(stock); } });
        }

        function calculatePortfolioValue() {
            let currentPortfolioValue = 0;
            Object.keys(portfolio).forEach(symbol => {
                const stock = stocks.find(s => s.symbol === symbol);
                const portfolioItem = portfolio[symbol];
                if (stock && portfolioItem && portfolioItem.quantity > 0) { currentPortfolioValue += portfolioItem.quantity * stock.price; }
            });
            return currentPortfolioValue;
        }

        // --- MODIFICADA: renderPortfolio para usar la predicci√≥n ---
        function renderPortfolio() {
            portfolioEl.innerHTML = '';
            const portfolioSymbols = Object.keys(portfolio);
            let currentPortfolioValue = 0;

            if (portfolioSymbols.length === 0 || portfolioSymbols.every(sym => !portfolio[sym] || portfolio[sym].quantity <= 0)) {
                portfolioEl.appendChild(emptyPortfolioMsgEl);
                emptyPortfolioMsgEl.style.display = 'block';
            } else {
                emptyPortfolioMsgEl.style.display = 'none';
                portfolioSymbols.forEach(symbol => {
                    const stock = stocks.find(s => s.symbol === symbol);
                    const portfolioItem = portfolio[symbol];

                    if (!stock || !portfolioItem || portfolioItem.quantity <= 0) {
                        if (portfolio[symbol]) delete portfolio[symbol];
                        return;
                    };

                    const marketValue = portfolioItem.quantity * stock.price;
                    const costBasis = portfolioItem.quantity * portfolioItem.avgPrice;
                    const gainLoss = marketValue - costBasis;
                    const gainLossPercent = portfolioItem.avgPrice !== 0 ? (gainLoss / costBasis) * 100 : 0;
                    const gainLossClass = gainLoss >= 0 ? 'price-up' : 'price-down';
                    currentPortfolioValue += marketValue;

                    // --- L√ìGICA DE LA FLECHA MODIFICADA ---
                    let trendSymbol = '';
                    if (showTrendIndicator && stock) {
                        // La flecha ahora usa 'predictedDirection', que es 100% certera
                        if (stock.predictedDirection === 'up') {
                            trendSymbol = '<span class="price-up ml-1 text-xs">‚ñ≤</span>';
                        } else if (stock.predictedDirection === 'down') {
                            trendSymbol = '<span class="price-down ml-1 text-xs">‚ñº</span>';
                        }
                    }

                    const portfolioDiv = document.createElement('div');
                    portfolioDiv.className = 'portfolio-item border border-gray-200 rounded-lg p-3 shadow-sm';
                    portfolioDiv.innerHTML = `
                        <div class="portfolio-info mb-3">
                            <div class="portfolio-name font-semibold text-gray-700">${stock.name} (${symbol})${trendSymbol}</div>
                            <div class="portfolio-details text-sm text-gray-600 space-y-1 mt-1">
                                <div>Cantidad: ${portfolioItem.quantity}</div>
                                <div>Precio Prom.: $${formatCurrency(portfolioItem.avgPrice)}</div>
                                <div>Precio Actual: $${formatCurrency(stock.price)}</div>
                                <div>Valor Mercado: $${formatCurrency(marketValue)}</div>
                            </div>
                            <div class="portfolio-gainloss text-sm mt-2 ${gainLossClass}">
                                <span class="font-semibold">G/P:</span> $${formatCurrency(gainLoss)} (${formatCurrency(gainLossPercent)}%)
                            </div>
                        </div>
                        <div class="sl-tp-controls border-t border-gray-200 pt-3 mt-3 flex items-center justify-start space-x-6">
                            <div class="flex items-center space-x-2">
                                <label for="sl-toggle-${symbol}" class="sl-tp-label">SL (${stopLossThreshold}%)</label>
                                <div class="relative inline-block w-10 align-middle select-none transition duration-200 ease-in">
                                    <input type="checkbox" name="sl-toggle-${symbol}" id="sl-toggle-${symbol}" class="toggle-checkbox" ${portfolioItem.slActive ? 'checked' : ''} onchange="toggleStopLoss('${symbol}')"/>
                                    <label for="sl-toggle-${symbol}" class="toggle-label"></label>
                                </div>
                            </div>
                            <div class="flex items-center space-x-2">
                                <label for="tp-toggle-${symbol}" class="sl-tp-label">TP (+${takeProfitThreshold}%)</label>
                                <div class="relative inline-block w-10 align-middle select-none transition duration-200 ease-in">
                                    <input type="checkbox" name="tp-toggle-${symbol}" id="tp-toggle-${symbol}" class="toggle-checkbox" ${portfolioItem.tpActive ? 'checked' : ''} onchange="toggleTakeProfit('${symbol}')"/>
                                    <label for="tp-toggle-${symbol}" class="toggle-label"></label>
                                </div>
                            </div>
                        </div>
                        <div class="manual-sell-controls border-t border-gray-200 pt-3 mt-3 flex flex-col items-start space-y-2 md:flex-row md:items-center md:space-y-0 md:space-x-2">
                             <label for="sell-portfolio-qty-${symbol}" class="text-sm font-medium text-gray-700">Vender:</label>
                             <input type="number" id="sell-portfolio-qty-${symbol}" min="1" value="1" class="portfolio-qty-input w-full md:w-14">
                             <button onclick="sellFromPortfolio('${symbol}')" class="sell-button w-full md:w-auto">Vender</button>
                         </div>`;
                    portfolioEl.appendChild(portfolioDiv);
                });
            }
            portfolioValueEl.textContent = formatCurrency(currentPortfolioValue);
            totalValueEl.textContent = formatCurrency(cash + currentPortfolioValue);
        }

        function buyStock(symbol) {
            if (isPaused) { showMessage('El mercado est√° pausado. Reanuda para operar.', 'error'); return; }
            const quantityInput = document.getElementById(`buy-qty-${symbol}`);
            const quantity = parseInt(quantityInput.value);
            const stock = stocks.find(s => s.symbol === symbol);
            if (!stock || isNaN(quantity) || quantity <= 0) { showMessage('Cantidad inv√°lida.', 'error'); quantityInput.focus(); return; }
            const cost = stock.price * quantity;
            if (cost > cash) { showMessage('No tienes suficiente dinero.', 'error'); return; }
            const buyPrice = stock.price;
            cash -= cost;
            if (portfolio[symbol]) {
                const existingQuantity = portfolio[symbol].quantity;
                const existingAvgPrice = portfolio[symbol].avgPrice;
                portfolio[symbol].avgPrice = ((existingAvgPrice * existingQuantity) + cost) / (existingQuantity + quantity);
                portfolio[symbol].quantity += quantity;
            } else { portfolio[symbol] = { quantity: quantity, avgPrice: buyPrice, slActive: false, tpActive: false }; }
            addTransaction('BUY', symbol, quantity, buyPrice);
            showMessage(`Compraste ${quantity} acciones de ${symbol} por $${formatCurrency(cost)}`, 'success');
            quantityInput.value = '1';
            updateGameInfo();
            renderPortfolio();
        }

        function sellFromPortfolio(symbol) {
             if (isPaused) { showMessage('El mercado est√° pausado. Reanuda para operar.', 'error'); return; }
             const inputId = `sell-portfolio-qty-${symbol}`;
             const quantityInput = document.getElementById(inputId);
             if (!quantityInput) { console.error(`Input not found: ${inputId}`); return; }
             const quantity = parseInt(quantityInput.value);
             const success = sellStock(symbol, quantity, false, '');
             if (success || (!success && quantity > 0)) { quantityInput.value = '1'; }
         }

        function sellStock(symbol, quantityToSell = 0, isAutoSell = false, triggerType = '') {
            if (!isAutoSell && isPaused) { showMessage('El mercado est√° pausado. Reanuda para operar.', 'error'); return false; }
            const stock = stocks.find(s => s.symbol === symbol);
            const quantity = quantityToSell;
            if (!stock || isNaN(quantity) || quantity <= 0) { if (!isAutoSell) showMessage('Cantidad inv√°lida.', 'error'); return false; }
            if (!portfolio[symbol] || portfolio[symbol].quantity < quantity) { if (!isAutoSell) showMessage(`No tienes suficientes acciones de ${symbol} para vender.`, 'error'); return false; }

            const sellPrice = stock.price;
            const avgPrice = portfolio[symbol].avgPrice;
            const revenue = sellPrice * quantity;
            cash += revenue;
            const soldQuantity = quantity;
            portfolio[symbol].quantity -= quantity;

            let transactionType = 'SELL';
            let messageType = 'success';
            if (isAutoSell) {
                transactionType = triggerType;
                messageType = triggerType === 'SL' ? 'error' : 'success';
            }

            addTransaction(transactionType, symbol, soldQuantity, sellPrice, avgPrice);

            if (portfolio[symbol].quantity === 0) { delete portfolio[symbol]; }

            if (isAutoSell) {
                if (triggerType === 'SL') showMessage(`¬°STOP-LOSS (${stopLossThreshold}%) ACTIVADO! Vendidas ${soldQuantity} acciones de ${symbol} a $${formatCurrency(sellPrice)}.`, messageType);
                else if (triggerType === 'TP') showMessage(`¬°TAKE-PROFIT (+${takeProfitThreshold}%) ACTIVADO! Vendidas ${soldQuantity} acciones de ${symbol} a $${formatCurrency(sellPrice)}.`, messageType);
                else showMessage(`¬°Venta Autom√°tica! Vendidas ${soldQuantity} acciones de ${symbol} a $${formatCurrency(sellPrice)}.`, 'info');
            } else {
                showMessage(`Vendiste ${soldQuantity} acciones de ${symbol} por $${formatCurrency(revenue)}`, messageType);
            }

            updateGameInfo();
            renderPortfolio();
            return true;
        }

        function addTransaction(type, symbol, quantity, price, avgPrice = null) {
            if (quantity > 0) {
                const transaction = { type: type, symbol: symbol, quantity: quantity, price: price, timestamp: new Date(), avgPrice: avgPrice };
                transactionHistory.push(transaction);
            } else {
                console.warn(`Intento de a√±adir transacci√≥n con cantidad 0 para ${symbol}`);
            }
        }

        function toggleStopLoss(symbol) {
            if (isPaused) {
                showMessage('El mercado est√° pausado. Reanuda para operar.', 'error');
                const cb = document.getElementById(`sl-toggle-${symbol}`);
                if(cb) cb.checked = !cb.checked;
                return;
            }
            if (portfolio[symbol]) {
                portfolio[symbol].slActive = !portfolio[symbol].slActive;
                showMessage(`Stop-Loss (${stopLossThreshold}%) para ${symbol} ${portfolio[symbol].slActive ? 'ACTIVADO' : 'DESACTIVADO'}.`, 'info');
            }
        }

        function toggleTakeProfit(symbol) {
             if (isPaused) {
                 showMessage('El mercado est√° pausado. Reanuda para operar.', 'error');
                 const cb = document.getElementById(`tp-toggle-${symbol}`);
                 if(cb) cb.checked = !cb.checked;
                 return;
             }
             if (portfolio[symbol]) {
                 portfolio[symbol].tpActive = !portfolio[symbol].tpActive;
                 showMessage(`Take-Profit (+${takeProfitThreshold}%) para ${symbol} ${portfolio[symbol].tpActive ? 'ACTIVADO' : 'DESACTIVADO'}.`, 'info');
             }
         }

        function checkAutoOrders() {
            const ordersToExecute = [];
            for (const symbol in portfolio) {
                const portfolioItem = portfolio[symbol];
                const stock = stocks.find(s => s.symbol === symbol);
                if (!stock || !portfolioItem || portfolioItem.quantity <= 0 || portfolioItem.avgPrice <= 0) continue;

                const currentPrice = stock.price;
                const avgPrice = portfolioItem.avgPrice;
                const gainLossPercent = ((currentPrice - avgPrice) / avgPrice) * 100;

                if (portfolioItem.slActive && gainLossPercent <= stopLossThreshold) {
                    ordersToExecute.push({ symbol: symbol, type: 'SL' });
                    continue;
                }
                if (portfolioItem.tpActive && gainLossPercent >= takeProfitThreshold) {
                    ordersToExecute.push({ symbol: symbol, type: 'TP' });
                }
            }
            ordersToExecute.forEach(order => {
                if (portfolio[order.symbol] && portfolio[order.symbol].quantity > 0) {
                    const quantityToSell = portfolio[order.symbol].quantity;
                    sellStock(order.symbol, quantityToSell, true, order.type);
                }
            });
        }

        // --- NUEVA FUNCI√ìN: Predice el resultado del tick ---
        function determineNextTickOutcomes() {
            manageEvents(); // Primero, determina si una nueva noticia empieza AHORA.

            stocks.forEach(stock => {
                let effectiveVolatility = stock.volatility;
                let effectiveTrend = stock.trend;

                activeEvents.forEach(activeEvent => {
                    if (activeEvent.event.target === 'ALL' || activeEvent.event.target === stock.symbol) {
                        if (!activeEvent.isNew || (activeEvent.isNew && activeEvent.remainingTicks === activeEvent.event.duration)) {
                            effectiveVolatility *= activeEvent.event.volatility_modifier;
                            effectiveTrend += activeEvent.event.trend_modifier;
                        }
                    }
                });
                
                effectiveTrend = Math.max(MIN_TREND * 2, Math.min(effectiveTrend, MAX_TREND * 2));
                const randomFactor = (Math.random() - 0.5) * 2;
                let priceChangePercent = randomFactor * effectiveVolatility + effectiveTrend;
                const newPrice = stock.price * (1 + priceChangePercent);

                // Guarda la predicci√≥n
                stock.predictedDirection = newPrice > stock.price ? 'up' : 'down';
            });
        }
        
        // --- MODIFICADA: simulatePriceChange ahora puede obedecer la predicci√≥n ---
        function simulatePriceChange() {
            stocks.forEach(stock => {
                stock.lastPrice = stock.price;

                let newPrice;

                if (showTrendIndicator) {
                    // MODO CREADOR: El precio OBEDECE la predicci√≥n
                    let forcedChangePercent;
                    if (stock.predictedDirection === 'up') {
                        // Forzar una subida aleatoria entre 1% y 4%
                        forcedChangePercent = (Math.random() * 0.03) + 0.01; 
                    } else { // 'down'
                        // Forzar una bajada aleatoria entre 1% y 4%
                        forcedChangePercent = -((Math.random() * 0.03) + 0.01);
                    }
                    newPrice = stock.price * (1 + forcedChangePercent);

                } else {
                    // MODO NORMAL: El precio es impredecible
                    let effectiveVolatility = stock.volatility;
                    let effectiveTrend = stock.trend;
                    activeEvents.forEach(activeEvent => {
                        if (activeEvent.event.target === 'ALL' || activeEvent.event.target === stock.symbol) {
                            if (!activeEvent.isNew || (activeEvent.isNew && activeEvent.remainingTicks === activeEvent.event.duration)) {
                                effectiveVolatility *= activeEvent.event.volatility_modifier;
                                effectiveTrend += activeEvent.event.trend_modifier;
                            }
                        }
                    });
                    effectiveTrend = Math.max(MIN_TREND * 2, Math.min(effectiveTrend, MAX_TREND * 2));
                    const randomFactor = (Math.random() - 0.5) * 2;
                    let priceChangePercent = randomFactor * effectiveVolatility + effectiveTrend;
                    newPrice = stock.price * (1 + priceChangePercent);
                }
                
                stock.price = Math.max(0.01, newPrice); // Asignar el nuevo precio

                stock.history.push({ tick: tickCounter, price: stock.price });
                if (stock.history.length > maxHistoryLength) {
                    stock.history.shift();
                }
            });
        }


        function updateStockTrends() {
             stocks.forEach(stock => {
                 const changeDirection = Math.random() < 0.5 ? -1 : 1;
                 let newTrend = stock.trend + changeDirection * TREND_CHANGE_AMOUNT;
                 newTrend = Math.max(MIN_TREND, Math.min(newTrend, MAX_TREND));
                 stock.trend = newTrend;
             });
         }

        function manageEvents() {
             activeEvents = activeEvents.filter(activeEvent => {
                 activeEvent.remainingTicks--;
                 if (activeEvent.remainingTicks <= 0) {
                     console.log(`Event ended: ${activeEvent.event.name}`);
                     return false;
                 }
                 return true;
             });
             activeEvents.forEach(ae => { if(ae.isNew) ae.isNew = false; });
             if (activeEvents.length < MAX_ACTIVE_EVENTS && Math.random() < EVENT_PROBABILITY) {
                 const availableEvents = marketEvents.filter(event => !activeEvents.some(ae => ae.event.name === event.name));
                 if (availableEvents.length > 0) {
                     const newEvent = availableEvents[Math.floor(Math.random() * availableEvents.length)];
                     activeEvents.push({ event: newEvent, remainingTicks: newEvent.duration, isNew: true });
                     console.log(`New event triggered: ${newEvent.name} (Duration: ${newEvent.duration} ticks)`);
                     showEventNotification(`${newEvent.message}`);
                 }
             }
         }


        function initializeChart() {
            const ctx = chartCanvas.getContext('2d');
            stockChart = new Chart(ctx, {
                type: 'line',
                data: { labels: [], datasets: [] },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    scales: {
                        y: { beginAtZero: false, ticks: { callback: value => '$' + formatCurrency(value) } },
                        x: { ticks: { display: false }, grid: { display: false } }
                    },
                    plugins: {
                        legend: { position: 'top' },
                        tooltip: {
                            mode: 'index', intersect: false,
                            callbacks: { label: context => `${context.dataset.label || ''}: $${formatCurrency(context.parsed.y)}` }
                        }
                    },
                    animation: { duration: 200 }
                }
            });
            updateChart();
        }

        function updateChart() {
             if (!stockChart) return;
             const visibleStocks = stocks.filter(stock => stock.showOnChart);
             let labels = [];
             let maxHistoryLengthFound = 0;
             if (visibleStocks.length > 0) {
                 visibleStocks.forEach(stock => {
                     if (stock.history && Array.isArray(stock.history) && stock.history.length > maxHistoryLengthFound) {
                         maxHistoryLengthFound = stock.history.length;
                         labels = stock.history.map(h => h.tick);
                     }
                 });
             }
             if (labels.length === 0 && tickCounter >= 0) {
                 const startTick = Math.max(0, tickCounter - maxHistoryLength + 1);
                 labels = [];
                 for (let i = startTick; i <= tickCounter; i++) labels.push(i);
             }
             if (labels.length > maxHistoryLength) {
                 labels = labels.slice(-maxHistoryLength);
             }

             stockChart.data.labels = labels;
             stockChart.data.datasets = visibleStocks.map(stock => {
                 const historyData = labels.map(tick => {
                     const historyPoint = stock.history?.find(h => h.tick === tick);
                     return historyPoint ? historyPoint.price : null;
                 });
                 return {
                     label: stock.symbol,
                     data: historyData,
                     borderColor: stock.color,
                     backgroundColor: stock.color + '33',
                     tension: 0.1,
                     pointRadius: 0,
                     pointHoverRadius: 5
                 };
             });
             stockChart.update();
         }


        function toggleChartVisibility(symbol) {
            const stock = stocks.find(s => s.symbol === symbol);
            if (stock) {
                stock.showOnChart = !stock.showOnChart;
                updateChart();
            }
        }

        // --- MODIFICADO: El ciclo principal del juego ---
                // --- MODIFICADO: El ciclo principal del juego (VERSI√ìN CORREGIDA) ---
        function updateMarket() {
            if (isPaused) return;

            tickCounter++;
            
            // 1. El precio cambia AHORA, usando la predicci√≥n que se calcul√≥ en el ciclo ANTERIOR.
            // Al principio, esta predicci√≥n es neutra, pero a partir del segundo tick, ya es una predicci√≥n real.
            simulatePriceChange();       

            // 2. Se calcula la predicci√≥n para el FUTURO. El resultado se guardar√° para usarse en el PR√ìXIMO tick.
            determineNextTickOutcomes(); 

            // 3. Se actualiza la lista de acciones con el precio actual.
            renderStockMarket();         
            
            // 4. Se actualiza la cartera. Ahora mostrar√° el precio ACTUAL y la flecha que predice el movimiento FUTURO.
            // Esta es la correcci√≥n clave.
            renderPortfolio();           

            // El resto de funciones se mantienen igual.
            checkAutoOrders();           
            updateChart();               
            saveGameState();             
        }

        function setPauseState(shouldPause) {
             isPaused = shouldPause;
             if (isPaused) {
                 if (gameInterval) { clearInterval(gameInterval); gameInterval = null; }
                 pauseResumeBtn.textContent = 'Reanudar';
                 pauseResumeBtn.classList.remove('pause-button');
                 pauseResumeBtn.classList.add('resume-button');
                 showMessage('Mercado pausado. Haz clic en Reanudar para continuar.', 'info');
             } else {
                 if (!gameInterval) {
                     updateMarket();
                     gameInterval = setInterval(updateMarket, updateInterval);
                 }
                 pauseResumeBtn.textContent = 'Pausar';
                 pauseResumeBtn.classList.remove('resume-button');
                 pauseResumeBtn.classList.add('pause-button');
                 showMessage('Mercado reanudado.', 'info');
             }
         }

        function togglePause() {
            setPauseState(!isPaused);
        }

        function showHistory() {
             historyListEl.innerHTML = '';
             if (transactionHistory.length === 0) {
                 historyListEl.innerHTML = '<li class="text-gray-500">No hay transacciones todav√≠a en esta sesi√≥n.</li>';
             } else {
                 [...transactionHistory].sort((a, b) => b.timestamp - a.timestamp).forEach(tx => {
                     const li = document.createElement('li');
                     li.className = 'history-list-item';
                     const timestamp = (tx.timestamp instanceof Date) ? tx.timestamp : new Date(tx.timestamp);
                     const stockInfo = stocks.find(s => s.symbol === tx.symbol);
                     const stockName = stockInfo ? stockInfo.name : tx.symbol;

                     let gainLossHTML = '';
                     if (['SELL', 'SL', 'TP'].includes(tx.type) && tx.avgPrice !== null && tx.avgPrice > 0) {
                         const realizedGainLoss = (tx.price - tx.avgPrice) * tx.quantity;
                         const gainLossClass = realizedGainLoss >= 0 ? 'price-up' : 'price-down';
                         gainLossHTML = `<div class="history-gain-loss ${gainLossClass}">Ganancia/P√©rdida: $${formatCurrency(realizedGainLoss)}</div>`;
                     }

                     li.innerHTML = `
                         <div class="history-main-line">
                             <span class="history-type-${tx.type}">${tx.type}</span>
                             <span>${stockName}:</span>
                             <span>${tx.quantity} acc.</span>
                             <span>@ $${formatCurrency(tx.price)}</span>
                             <span class="text-gray-500 text-xs float-right">${formatTimestamp(timestamp)}</span>
                         </div>
                         ${gainLossHTML}`;
                     historyListEl.appendChild(li);
                 });
             }
             historyModal.classList.remove('hidden');
         }

        function closeHistory() { historyModal.classList.add('hidden'); }

        function getCurrentGlobalBalance() {
            try {
                const savedBalance = localStorage.getItem(BALANCE_LOCAL_STORAGE_KEY);
                if (savedBalance !== null) { const parsedBalance = parseInt(savedBalance); if (!isNaN(parsedBalance)) { return parsedBalance; } }
            } catch (error) { console.error("Error al leer el saldo global desde localStorage:", error); }
            return DEFAULT_BALANCE;
        }

        function saveGlobalBalance(newBalance) {
             try {
                 const balanceToSave = Math.round(newBalance);
                 if (isNaN(balanceToSave)) { console.error("Intento de guardar un saldo global inv√°lido (NaN)."); return; }
                 localStorage.setItem(BALANCE_LOCAL_STORAGE_KEY, balanceToSave.toString());
                 console.log(`Nuevo saldo global guardado: ${balanceToSave}`);
             } catch (error) { console.error("Error al guardar el saldo global en localStorage:", error); showMessage("Error al actualizar el saldo global.", "error"); }
         }

        function saveGameState() {
            try {
                const gameState = {
                    cash: cash, 
                    stocks: stocks.map(s => ({
                        symbol: s.symbol, name: s.name, price: s.price, lastPrice: s.lastPrice,
                        volatility: s.volatility, trend: s.trend, color: s.color,
                        showOnChart: s.showOnChart, history: s.history,
                        predictedDirection: s.predictedDirection // Guardar la predicci√≥n
                    })),
                    portfolio: portfolio,
                    tickCounter: tickCounter,
                    activeEvents: activeEvents,
                    showTrendIndicator: showTrendIndicator,
                };
                sessionStorage.setItem(STOCK_GAME_STATE_KEY, JSON.stringify(gameState));
            } catch (error) {
                console.error("Error al guardar el estado del juego en sessionStorage:", error);
            }
        }

        function loadGameState() {
            let loadedFromSave = false;
            try {
                const initialInvestmentStr = sessionStorage.getItem(GAME6_INVESTMENT_SESSION_KEY);
                let parsedInvestment = 10000;
                if (initialInvestmentStr) {
                    const tempInvestment = parseInt(initialInvestmentStr);
                    if (!isNaN(tempInvestment) && tempInvestment > 0) { parsedInvestment = tempInvestment; }
                }
                initialInvestment = parsedInvestment;

                const savedStateStr = sessionStorage.getItem(STOCK_GAME_STATE_KEY);
                if (savedStateStr) {
                    console.log("Cargando estado del juego desde sessionStorage...");
                    const savedState = JSON.parse(savedStateStr);
                    cash = savedState.cash !== undefined ? savedState.cash : initialInvestment;
                    stocks = savedState.stocks.map(s => ({
                         ...s,
                         lastPrice: s.lastPrice !== undefined ? s.lastPrice : s.price,
                         history: Array.isArray(s.history) ? s.history : [{ tick: 0, price: s.price }],
                         predictedDirection: s.predictedDirection || 'neutral' // Cargar la predicci√≥n
                     }));
                    portfolio = savedState.portfolio || {};
                    transactionHistory = [];
                    tickCounter = savedState.tickCounter || 0;
                    activeEvents = (savedState.activeEvents || []).map(ae => ({...ae, isNew: false}));
                    showTrendIndicator = savedState.showTrendIndicator || false;
                    isPaused = true; 
                    loadedFromSave = true;
                    showMessage(`Partida anterior cargada. Mercado pausado.`, "info");
                } else {
                    console.log("No se encontr√≥ estado guardado. Iniciando nueva partida.");
                    cash = initialInvestment;
                    stocks = initialStockData.map(initialStock => ({
                        ...initialStock, lastPrice: initialStock.price,
                        history: [{ tick: 0, price: initialStock.price }],
                        predictedDirection: 'neutral' // A√±adir propiedad al inicio
                    }));
                    portfolio = {};
                    transactionHistory = [];
                    tickCounter = 0;
                    activeEvents = []; showTrendIndicator = false; isPaused = false;
                    showMessage(`Inversi√≥n inicial: $${formatCurrency(cash)}. El mercado se actualiza cada ${updateInterval / 1000}s.`, "info");
                }
            } catch (error) {
                console.error("Error al cargar el estado del juego:", error);
                cash = initialInvestment > 0 ? initialInvestment : 10000;
                stocks = initialStockData.map(initialStock => ({ ...initialStock, lastPrice: initialStock.price, history: [{ tick: 0, price: initialStock.price }], predictedDirection: 'neutral' }));
                portfolio = {}; transactionHistory = []; tickCounter = 0;
                activeEvents = []; isPaused = false; showTrendIndicator = false;
                showMessage("Error al cargar datos. Iniciando nueva partida.", "error");
            }
            return loadedFromSave;
        }

        function initializeGame() {
            const loadedFromSave = loadGameState();
            buildStockMarketList();
            renderPortfolio();
            updateGameInfo();
            initializeChart();
            setPauseState(isPaused);

            const cashDisplayElement = document.getElementById('cash');
            if (cashDisplayElement) {
                cashDisplayElement.addEventListener('dblclick', () => {
                    showTrendIndicator = !showTrendIndicator;
                    // Forzar una actualizaci√≥n de la cartera para mostrar/ocultar las flechas inmediatamente
                    renderPortfolio();
                    showMessage(`Indicador de Creador ${showTrendIndicator ? 'ACTIVADO (Predicci√≥n Perfecta)' : 'DESACTIVADO (Modo Normal)'}.`, 'info');
                });
            } else { console.error("Elemento #cash no encontrado para a√±adir listener de doble clic."); }
        }

        function handleExitClick(event) {
            event.preventDefault();
            if (!isPaused) { setPauseState(true); } 
            saveGameState(); 
            try {
                const finalPortfolioValue = calculatePortfolioValue();
                const finalTotalValue = cash + finalPortfolioValue;
                const netGainLoss = finalTotalValue - initialInvestment;
                const currentGlobalBalance = getCurrentGlobalBalance();
                const newGlobalBalance = currentGlobalBalance + netGainLoss;
                saveGlobalBalance(newGlobalBalance);
            } catch (error) {
                console.error("Error durante el proceso de actualizaci√≥n del saldo global al salir:", error);
                showMessage("Ocurri√≥ un error al actualizar tu saldo global.", "error");
            }
            window.location.href = event.target.href;
        }

        // --- Event Listeners ---
        pauseResumeBtn.addEventListener('click', togglePause);
        historyModal.addEventListener('click', (event) => { if (event.target === historyModal) { closeHistory(); } });
        exitButton.addEventListener('click', handleExitClick);

        // Iniciar el juego
        window.onload = initializeGame;

    </script>
</body>
</html>