<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Bolsa - Estrategia Avanzada</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.4.0/dist/chartjs-plugin-annotation.min.js"></script>
    <style>
        /* Estilos sin cambios */
        body { background-color: #f3f4f6; font-family: 'Inter', sans-serif; }
        .price-up { color: #10b981; }
        .price-down { color: #ef4444; }
        input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        input[type=number] { -moz-appearance: textfield; }
        .action-button { @apply px-3 py-1 text-xs font-medium text-white rounded shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2; }
        .buy-button { @apply bg-emerald-600 hover:bg-emerald-700 focus:ring-emerald-500 action-button; }
        .sell-button { @apply bg-rose-600 hover:bg-rose-700 focus:ring-rose-500 action-button; }
        .control-button { @apply px-4 py-2 font-semibold text-white rounded shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 transition duration-150 ease-in-out; }
        .pause-button { @apply bg-blue-600 hover:bg-blue-700 focus:ring-blue-500 control-button; }
        .resume-button { @apply bg-red-600 hover:bg-red-700 focus:ring-red-500 control-button; }
        .history-button { @apply bg-gray-600 hover:bg-gray-700 focus:ring-gray-500 control-button; }
        .chart-container { height: 300px; position: relative; margin-top: 1.5rem; }
        .toggle-checkbox:checked { right: 0; border-color: #68D391; }
        .toggle-checkbox:checked + .toggle-label { background-color: #68D391; }
        .toggle-checkbox { @apply absolute block w-4 h-4 mt-1 ml-1 rounded-full bg-white border-2 appearance-none cursor-pointer; transition: right 0.2s ease-in-out; }
        .toggle-label { @apply block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer; width: 40px; transition: background-color 0.2s ease-in-out; }
        .sl-tp-label { @apply text-xs font-medium text-gray-600; }
        .modal { @apply fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50 flex items-center justify-center; }
        .modal-content { @apply relative mx-auto p-5 border w-full max-w-2xl shadow-lg rounded-md bg-white; }
        .modal-close { @apply absolute top-0 right-0 cursor-pointer p-4 text-xl font-bold text-gray-700 hover:text-red-500; }
        .history-list-item { @apply border-b border-gray-200 py-3 text-sm; }
        .history-main-line span { @apply mr-2; }
        .history-gain-loss { @apply text-xs pl-4; }
        .history-type-BUY { @apply font-semibold text-green-600; }
        .history-type-SELL { @apply font-semibold text-red-600; }
        .history-type-SL { @apply font-semibold text-red-800; }
        .history-type-TP { @apply font-semibold text-green-800; }
        .portfolio-qty-input { @apply px-2 py-1 border border-gray-300 rounded text-sm text-center focus:ring-1 focus:ring-blue-500 focus:border-blue-500; }
        .menu-link-button { @apply inline-block bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-150 ease-in-out text-sm no-underline focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500; }
        #cash { cursor: pointer; user-select: none; -webkit-user-select: none; }
        #event-notification-banner { transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out; opacity: 0; transform: translateY(-100%); pointer-events: none; }
        #event-notification-banner.visible { opacity: 1; transform: translateY(0); pointer-events: auto; }
    </style>
     <link rel="preconnect" href="https://rsms.me/">
     <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
     <style> body { font-family: 'Inter var', sans-serif; } </style>
</head>
<body class="min-h-screen">

    <div id="event-notification-banner" class="fixed top-4 left-1/2 -translate-x-1/2 z-[1000] px-6 py-3 rounded-lg shadow-lg text-white text-sm font-semibold bg-indigo-600 hidden">
    </div>

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        <header class="mb-8 p-4 bg-white rounded-lg shadow-md">
             <h1 class="text-2xl md:text-3xl font-bold text-gray-800 text-center mb-4">Simulador de Bolsa</h1>
             <div class="flex flex-wrap justify-around text-center text-sm md:text-base text-gray-700">
                 <div class="info-item mx-2 my-1"><span class="font-semibold">Dinero:</span> $<span id="cash">Cargando...</span></div>
                 <div class="info-item mx-2 my-1"><span class="font-semibold">Valor Cartera:</span> $<span id="portfolio-value">0,00</span></div>
                 <div class="info-item mx-2 my-1"><span class="font-semibold">Valor Total:</span> $<span id="total-value">Cargando...</span></div>
             </div>
          </header>

        <main class="grid grid-cols-1 md:grid-cols-2 gap-6 md:gap-8 mb-8">
            <section id="market-chart-section" class="bg-white p-4 md:p-6 rounded-lg shadow-md">
                <h2 class="text-xl md:text-2xl font-semibold text-gray-800 mb-4">Mercado de Acciones</h2>
                <div class="chart-container mb-2">
                    <canvas id="stockChart"></canvas>
                </div>
                <h3 class="text-lg font-semibold text-gray-700 mt-4 mb-2">√çndice de Fuerza Relativa (RSI)</h3>
                <div class="chart-container" style="height: 150px;">
                    <canvas id="rsiChart"></canvas>
                </div>
            </section>

             <section id="portfolio-section" class="bg-white p-4 md:p-6 rounded-lg shadow-md">
                <h2 class="text-xl md:text-2xl font-semibold text-gray-800 mb-4">Mi Cartera</h2>
                <div id="portfolio" class="space-y-4">
                    <p id="empty-portfolio-msg" class="text-gray-500">A√∫n no tienes acciones.</p>
                </div>
             </section>

             <section id="market-list-section" class="bg-white p-4 md:p-6 rounded-lg shadow-md md:col-span-2">
                <h3 class="text-lg font-semibold text-gray-700 mb-3">Acciones Disponibles</h3>
                <div id="stock-market" class="space-y-4">
                    <p class="text-gray-500">Cargando mercado...</p>
                </div>
             </section>
        </main>

        <footer class="text-center space-y-4 pb-8">
             <div id="message-box" class="p-3 bg-gray-100 border border-gray-300 rounded-md text-gray-700 min-h-[40px] text-sm md:text-base">
                 Cargando simulador...
             </div>
             <div class="controls flex justify-center space-x-4">
                 <button id="pause-resume-btn" class="pause-button">Pausar</button>
                 <button id="history-btn" onclick="showHistory()" class="history-button">Mostrar Historial</button>
             </div>
             <div class="mt-4">
                 <a href="../index.html" id="exit-button" class="menu-link-button">
                     ‚Üê Men√∫
                 </a>
             </div>
        </footer>

         <div id="history-modal" class="modal hidden">
             <div class="modal-content">
                 <span class="modal-close" onclick="closeHistory()">√ó</span>
                 <h3 class="text-xl font-semibold mb-4 text-gray-800">Historial de Transacciones</h3>
                 <div class="max-h-96 overflow-y-auto">
                     <ul id="history-list">
                         <li class="text-gray-500">No hay transacciones todav√≠a.</li>
                     </ul>
                 </div>
             </div>
          </div>

    </div>

    <script>
        // --- Constantes de Storage ---
        const BALANCE_LOCAL_STORAGE_KEY = 'cardGamePlayerBalance_v3';
        const GAME6_INVESTMENT_SESSION_KEY = 'game6InitialInvestment';
        const STOCK_GAME_STATE_KEY = 'stockSimGameState_v2';
        const DEFAULT_BALANCE = 5000;

        // --- Configuraci√≥n Inicial ---
        let cash = 10000;
        let portfolio = {};
        const initialStockData = [
            // A√±adidos estados para el impacto del RSI
            { symbol: 'TECH', name: 'Tech Corp üíª', price: 150.00, volatility: 0.055, trend: 0.00002, color: '#3B82F6', showOnChart: true, stma: 150.00, ltma: 150.00, trendState: 'neutral', trendTicksRemaining: 0, stmaHistory: [], ltmaHistory: [], rsi: 50, avgGain: 0, avgLoss: 0, rsi_history: [], rsiReversalTicks: 0, wasOverbought: false, wasOversold: false },
            { symbol: 'FOOD', name: 'Foodies Inc üçî', price: 50.00, volatility: 0.030, trend: 0.00001, color: '#F59E0B', showOnChart: true, stma: 50.00, ltma: 50.00, trendState: 'neutral', trendTicksRemaining: 0, stmaHistory: [], ltmaHistory: [], rsi: 50, avgGain: 0, avgLoss: 0, rsi_history: [], rsiReversalTicks: 0, wasOverbought: false, wasOversold: false },
            { symbol: 'GAME', name: 'GameDev Co üéÆ', price: 80.00, volatility: 0.070, trend: -0.00001, color: '#8B5CF6', showOnChart: true, stma: 80.00, ltma: 80.00, trendState: 'neutral', trendTicksRemaining: 0, stmaHistory: [], ltmaHistory: [], rsi: 50, avgGain: 0, avgLoss: 0, rsi_history: [], rsiReversalTicks: 0, wasOverbought: false, wasOversold: false },
            { symbol: 'FIN', name: 'Finance Hub üí∞', price: 200.00, volatility: 0.045, trend: 0.000015, color: '#10B981', showOnChart: true, stma: 200.00, ltma: 200.00, trendState: 'neutral', trendTicksRemaining: 0, stmaHistory: [], ltmaHistory: [], rsi: 50, avgGain: 0, avgLoss: 0, rsi_history: [], rsiReversalTicks: 0, wasOverbought: false, wasOversold: false },
            { symbol: 'ECO', name: 'Eco Energy üåø', price: 70.00, volatility: 0.065, trend: 0.00003, color: '#6B7280', showOnChart: true, stma: 70.00, ltma: 70.00, trendState: 'neutral', trendTicksRemaining: 0, stmaHistory: [], ltmaHistory: [], rsi: 50, avgGain: 0, avgLoss: 0, rsi_history: [], rsiReversalTicks: 0, wasOverbought: false, wasOversold: false }
        ];
        let stocks = [];
        let transactionHistory = [];
        const stopLossThreshold = -4.0;
        const takeProfitThreshold = 5.0;
        let gameInterval = null;
        let isPaused = false;
        const updateInterval = 10000;
        const maxHistoryLength = 60;
        let tickCounter = 0;
        let initialInvestment = 0;

        const EVENT_PROBABILITY = 0.25;
        const MAX_ACTIVE_EVENTS = 2;
        let activeEvents = [];

        const marketEvents = [
             { name: "Optimismo Global Cauteloso", message: "üì∞ El mercado muestra optimismo, pero los analistas piden cautela. ¬øOportunidad o trampa?", target: 'ALL', duration: 3, volatility_modifier: 2.5, trend_modifier: -0.00005 },
             { name: "Temor a Recesi√≥n", message: "üì∞ Aumentan los temores de recesi√≥n, pero algunos ven oportunidades de compra.", target: 'ALL', duration: 3, volatility_modifier: 2.8, trend_modifier: 0.00006 },
             { name: "Anuncio Tecnol√≥gico", message: "üì∞ Tech Corp har√° un 'anuncio importante' esta semana. El mercado especula.", target: 'TECH', duration: 3, volatility_modifier: 3.0, trend_modifier: 0.0003 },
             { name: "Regulaci√≥n Tecnol√≥gica", message: "üì∞ Se anuncian nuevas regulaciones para el sector Tech. ¬øProteger√°n al consumidor o ahogar√°n la innovaci√≥n?", target: 'TECH', duration: 3, volatility_modifier: 2.9, trend_modifier: -0.00015 },
             { name: "Movimientos en la Banca", message: "üì∞ Finance Hub reporta 'movimientos inesperados' en sus cuentas. ¬øBueno o malo?", target: 'FIN', duration: 3, volatility_modifier: 2.5, trend_modifier: 0.00015 },
             { name: "Ca√≠da del Petr√≥leo", message: "üì∞ El petr√≥leo se desploma. Malo para las petroleras, ¬øpero bueno para los costes de Eco Energy?", target: 'ECO', duration: 3, volatility_modifier: 3.1, trend_modifier: 0.00018 },
             { name: "Nuevo Proyecto de GameDev", message: "üì∞ GameDev Co. anuncia un proyecto secreto llamado 'Prometeo'. La comunidad est√° dividida.", target: 'GAME', duration: 3, volatility_modifier: 3.5, trend_modifier: 0.0004 },
             { name: "Cadena de Suministro", message: "üì∞ Foodies Inc reestructura su cadena de suministro. ¬øReducci√≥n de costes o se√±al de problemas?", target: 'FOOD', duration: 3, volatility_modifier: 2.8, trend_modifier: -0.00009 },
             { name: "Datos de Inflaci√≥n", message: "üìä ¬°Datos de inflaci√≥n generan alta incertidumbre y volatilidad!", target: 'ALL', duration: 3, volatility_modifier: 2.7, trend_modifier: -0.00003 },
             { name: "Desastre Natural", message: "üå™Ô∏è ¬°Desastre natural impacta la econom√≠a global!", target: 'ALL', duration: 3, volatility_modifier: 2.9, trend_modifier: -0.00010 },
        ];
        let eventNotificationTimeout = null;

        const cashEl = document.getElementById('cash');
        const portfolioValueEl = document.getElementById('portfolio-value');
        const totalValueEl = document.getElementById('total-value');
        const stockMarketEl = document.getElementById('stock-market');
        const portfolioEl = document.getElementById('portfolio');
        const emptyPortfolioMsgEl = document.getElementById('empty-portfolio-msg');
        const pauseResumeBtn = document.getElementById('pause-resume-btn');
        const messageBoxEl = document.getElementById('message-box');
        const chartCanvas = document.getElementById('stockChart');
        const historyModal = document.getElementById('history-modal');
        const historyListEl = document.getElementById('history-list');
        const exitButton = document.getElementById('exit-button');
        const eventNotificationBanner = document.getElementById('event-notification-banner');
        let stockChart = null;
        let rsiChart = null;

        function showMessage(msg, type = 'info') {
            messageBoxEl.textContent = msg;
            messageBoxEl.className = 'p-3 border rounded-md min-h-[40px] text-sm md:text-base';
            switch (type) {
                case 'error': messageBoxEl.classList.add('bg-red-100', 'border-red-400', 'text-red-700'); break;
                case 'success': messageBoxEl.classList.add('bg-green-100', 'border-green-400', 'text-green-700'); break;
                case 'info': default: messageBoxEl.classList.add('bg-yellow-100', 'border-yellow-400', 'text-yellow-700'); break;
            }
        }

        function showEventNotification(msg) {
             if (!eventNotificationBanner) return;
             eventNotificationBanner.textContent = msg;
             eventNotificationBanner.classList.remove('hidden');
             void eventNotificationBanner.offsetWidth;
             eventNotificationBanner.classList.add('visible');
             if (eventNotificationTimeout) { clearTimeout(eventNotificationTimeout); }
             eventNotificationTimeout = setTimeout(() => {
                 eventNotificationBanner.classList.remove('visible');
                 setTimeout(() => { if (!eventNotificationBanner.classList.contains('visible')) { eventNotificationBanner.classList.add('hidden'); } }, 500);
                 eventNotificationTimeout = null;
             }, 15000);
         }

        function formatCurrency(amount) {
            if (typeof amount !== 'number' || isNaN(amount)) { return '0,00'; }
            return amount.toLocaleString('es-ES', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        }

        function formatTimestamp(date) {
            if (!(date instanceof Date) || isNaN(date.getTime())) return 'Fecha inv√°lida';
            return date.toLocaleString('es-ES', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit' });
        }

        function updateGameInfo() {
            cashEl.textContent = formatCurrency(cash);
            const currentPortfolioValue = calculatePortfolioValue();
            portfolioValueEl.textContent = formatCurrency(currentPortfolioValue);
            totalValueEl.textContent = formatCurrency(cash + currentPortfolioValue);
        }

        function buildStockMarketList() {
            stockMarketEl.innerHTML = '';
            if (stocks.length === 0) { stockMarketEl.innerHTML = '<p class="text-gray-500">No hay acciones disponibles.</p>'; return; }
            stocks.forEach(stock => {
                const stockDiv = document.createElement('div');
                stockDiv.id = `stock-item-${stock.symbol}`;
                stockDiv.className = 'stock-item border border-gray-200 rounded-lg p-3 shadow-sm flex flex-wrap justify-between items-center';
                stockDiv.innerHTML = `
                    <div class="flex-grow flex items-center mb-2 md:mb-0 mr-4">
                        <div class="relative inline-block w-10 mr-3 align-middle select-none transition duration-200 ease-in">
                            <input type="checkbox" name="toggle-${stock.symbol}" id="toggle-${stock.symbol}" class="toggle-checkbox" ${stock.showOnChart ? 'checked' : ''} onchange="toggleChartVisibility('${stock.symbol}')"/>
                            <label for="toggle-${stock.symbol}" class="toggle-label"></label>
                        </div>
                        <div class="stock-info">
                            <div class="stock-name font-semibold text-gray-700">${stock.name} (${stock.symbol})</div>
                            <div class="stock-price text-sm text-gray-600">
                                Precio: <span id="price-value-${stock.symbol}">$${formatCurrency(stock.price)}</span>
                                <span class="price-change-indicator font-bold ml-2" id="change-indicator-${stock.symbol}"></span>
                            </div>
                        </div>
                    </div>
                    <div class="actions flex items-center space-x-2 mt-2 md:mt-0 w-full md:w-auto justify-end">
                        <input type="number" id="buy-qty-${stock.symbol}" min="1" value="1" class="portfolio-qty-input w-16">
                        <button onclick="buyFromInput('${stock.symbol}')" class="buy-button">Comprar</button>
                        <button onclick="buyMaxStock('${stock.symbol}')" class="buy-button bg-blue-600 hover:bg-blue-700 focus:ring-blue-500">Max</button>
                    </div>`;
                stockMarketEl.appendChild(stockDiv);
                updateStockItemDisplay(stock);
            });
        }

        function updateStockItemDisplay(stock) {
             const priceValueEl = document.getElementById(`price-value-${stock.symbol}`);
             const changeIndicatorEl = document.getElementById(`change-indicator-${stock.symbol}`);
             if (!priceValueEl || !changeIndicatorEl) return;
             const priceChange = (stock.lastPrice !== undefined && stock.lastPrice !== null) ? stock.price - stock.lastPrice : 0;
             const changeIndicatorSymbol = priceChange > 0 ? '‚ñ≤' : (priceChange < 0 ? '‚ñº' : '');
             const changeClass = priceChange > 0 ? 'price-up' : (priceChange < 0 ? 'price-down' : 'text-gray-500');
             priceValueEl.textContent = `$${formatCurrency(stock.price)}`;
             changeIndicatorEl.textContent = `${changeIndicatorSymbol} ${formatCurrency(Math.abs(priceChange))}`;
             changeIndicatorEl.className = `price-change-indicator font-bold ml-2 ${changeClass}`;
         }

        function renderStockMarket() {
            stocks.forEach(stock => { if (document.getElementById(`stock-item-${stock.symbol}`)) { updateStockItemDisplay(stock); } });
        }

        function calculatePortfolioValue() {
            let currentPortfolioValue = 0;
            Object.keys(portfolio).forEach(symbol => {
                const stock = stocks.find(s => s.symbol === symbol);
                const portfolioItem = portfolio[symbol];
                if (stock && portfolioItem && portfolioItem.quantity > 0) { currentPortfolioValue += portfolioItem.quantity * stock.price; }
            });
            return currentPortfolioValue;
        }

        function renderPortfolio() {
            portfolioEl.innerHTML = '';
            const portfolioSymbols = Object.keys(portfolio);
            let currentPortfolioValue = 0;

            if (portfolioSymbols.length === 0 || portfolioSymbols.every(sym => !portfolio[sym] || portfolio[sym].quantity <= 0)) {
                portfolioEl.appendChild(emptyPortfolioMsgEl);
                emptyPortfolioMsgEl.style.display = 'block';
            } else {
                emptyPortfolioMsgEl.style.display = 'none';
                portfolioSymbols.forEach(symbol => {
                    const stock = stocks.find(s => s.symbol === symbol);
                    const portfolioItem = portfolio[symbol];

                    if (!stock || !portfolioItem || portfolioItem.quantity <= 0) {
                        if (portfolio[symbol]) delete portfolio[symbol];
                        return;
                    };

                    const marketValue = portfolioItem.quantity * stock.price;
                    const costBasis = portfolioItem.quantity * portfolioItem.avgPrice;
                    const gainLoss = marketValue - costBasis;
                    const gainLossPercent = portfolioItem.avgPrice !== 0 ? (gainLoss / costBasis) * 100 : 0;
                    const gainLossClass = gainLoss >= 0 ? 'price-up' : 'price-down';
                    currentPortfolioValue += marketValue;

                    const portfolioDiv = document.createElement('div');
                    portfolioDiv.className = 'portfolio-item border border-gray-200 rounded-lg p-3 shadow-sm';
                    portfolioDiv.innerHTML = `
                        <div class="portfolio-info mb-3">
                            <div class="portfolio-name font-semibold text-gray-700">${stock.name} (${symbol})</div>
                            <div class="portfolio-details text-sm text-gray-600 space-y-1 mt-1">
                                <div>Cantidad: ${portfolioItem.quantity}</div>
                                <div>Precio Prom.: $${formatCurrency(portfolioItem.avgPrice)}</div>
                                <div>Precio Actual: $${formatCurrency(stock.price)}</div>
                                <div>Valor Mercado: $${formatCurrency(marketValue)}</div>
                            </div>
                            <div class="portfolio-gainloss text-sm mt-2 ${gainLossClass}">
                                <span class="font-semibold">G/P:</span> $${formatCurrency(gainLoss)} (${formatCurrency(gainLossPercent)}%)
                            </div>
                        </div>
                        <div class="sl-tp-controls border-t border-gray-200 pt-3 mt-3 flex items-center justify-start space-x-6">
                            <div class="flex items-center space-x-2">
                                <label for="sl-toggle-${symbol}" class="sl-tp-label">SL (${stopLossThreshold}%)</label>
                                <div class="relative inline-block w-10 align-middle select-none transition duration-200 ease-in">
                                    <input type="checkbox" name="sl-toggle-${symbol}" id="sl-toggle-${symbol}" class="toggle-checkbox" ${portfolioItem.slActive ? 'checked' : ''} onchange="toggleStopLoss('${symbol}')"/>
                                    <label for="sl-toggle-${symbol}" class="toggle-label"></label>
                                </div>
                            </div>
                            <div class="flex items-center space-x-2">
                                <label for="tp-toggle-${symbol}" class="sl-tp-label">TP (+${takeProfitThreshold}%)</label>
                                <div class="relative inline-block w-10 align-middle select-none transition duration-200 ease-in">
                                    <input type="checkbox" name="tp-toggle-${symbol}" id="tp-toggle-${symbol}" class="toggle-checkbox" ${portfolioItem.tpActive ? 'checked' : ''} onchange="toggleTakeProfit('${symbol}')"/>
                                    <label for="tp-toggle-${symbol}" class="toggle-label"></label>
                                </div>
                            </div>
                        </div>
                        <div class="manual-sell-controls border-t border-gray-200 pt-3 mt-3 flex flex-col items-start space-y-2 md:flex-row md:items-center md:space-y-0 md:space-x-2">
                             <label for="sell-portfolio-qty-${symbol}" class="text-sm font-medium text-gray-700">Vender:</label>
                             <input type="number" id="sell-portfolio-qty-${symbol}" min="1" value="1" class="portfolio-qty-input w-full md:w-14">
                             <button onclick="sellFromPortfolio('${symbol}')" class="sell-button w-full md:w-auto">Vender</button>
                             <button onclick="sellAllFromPortfolio('${symbol}')" class="sell-button w-full md:w-auto">Vender Todo</button>
                         </div>`;
                    portfolioEl.appendChild(portfolioDiv);
                });
            }
            portfolioValueEl.textContent = formatCurrency(currentPortfolioValue);
            totalValueEl.textContent = formatCurrency(cash + currentPortfolioValue);
        }

        function buyFromInput(symbol) {
            const quantityInput = document.getElementById(`buy-qty-${symbol}`);
            const quantity = parseInt(quantityInput.value);
            buyStock(symbol, quantity);
        }

        function buyStock(symbol, quantity) {
            if (isPaused) { showMessage('El mercado est√° pausado. Reanuda para operar.', 'error'); return; }
            const stock = stocks.find(s => s.symbol === symbol);
            if (!stock || isNaN(quantity) || quantity <= 0) { showMessage('Cantidad inv√°lida.', 'error'); return; }
            const cost = stock.price * quantity;
            if (cost > cash) { showMessage('No tienes suficiente dinero.', 'error'); return; }
            const buyPrice = stock.price;
            cash -= cost;
            if (portfolio[symbol]) {
                const existingQuantity = portfolio[symbol].quantity;
                const existingAvgPrice = portfolio[symbol].avgPrice;
                portfolio[symbol].avgPrice = ((existingAvgPrice * existingQuantity) + cost) / (existingQuantity + quantity);
                portfolio[symbol].quantity += quantity;
            } else { portfolio[symbol] = { quantity: quantity, avgPrice: buyPrice, slActive: false, tpActive: false }; }
            addTransaction('BUY', symbol, quantity, buyPrice);
            showMessage(`Compraste ${quantity} acciones de ${symbol} por $${formatCurrency(cost)}`, 'success');
            const quantityInput = document.getElementById(`buy-qty-${symbol}`);
            if(quantityInput) quantityInput.value = '1';
            updateGameInfo();
            renderPortfolio();
        }

        function buyMaxStock(symbol) {
            if (isPaused) { showMessage('El mercado est√° pausado. Reanuda para operar.', 'error'); return; }
            const stock = stocks.find(s => s.symbol === symbol);
            if (!stock || stock.price <= 0) { return; }

            const maxQuantity = Math.floor(cash / stock.price);

            if (maxQuantity <= 0) {
                showMessage('No tienes suficiente dinero para comprar ni una acci√≥n.', 'error');
                return;
            }
            buyStock(symbol, maxQuantity);
        }

        function sellFromPortfolio(symbol) {
             if (isPaused) { showMessage('El mercado est√° pausado. Reanuda para operar.', 'error'); return; }
             const inputId = `sell-portfolio-qty-${symbol}`;
             const quantityInput = document.getElementById(inputId);
             if (!quantityInput) { console.error(`Input not found: ${inputId}`); return; }
             const quantity = parseInt(quantityInput.value);
             const success = sellStock(symbol, quantity, false, '');
             if (success || (!success && quantity > 0)) { quantityInput.value = '1'; }
         }

        function sellAllFromPortfolio(symbol) {
            if (isPaused) { showMessage('El mercado est√° pausado. Reanuda para operar.', 'error'); return; }
            if (!portfolio[symbol] || portfolio[symbol].quantity <= 0) {
                showMessage('No tienes acciones de este tipo para vender.', 'error');
                return;
            }
            const quantityToSell = portfolio[symbol].quantity;
            sellStock(symbol, quantityToSell, false, '');
        }

        function sellStock(symbol, quantityToSell = 0, isAutoSell = false, triggerType = '') {
            if (!isAutoSell && isPaused) { showMessage('El mercado est√° pausado. Reanuda para operar.', 'error'); return false; }
            const stock = stocks.find(s => s.symbol === symbol);
            const quantity = quantityToSell;
            if (!stock || isNaN(quantity) || quantity <= 0) { if (!isAutoSell) showMessage('Cantidad inv√°lida.', 'error'); return false; }
            if (!portfolio[symbol] || portfolio[symbol].quantity < quantity) { if (!isAutoSell) showMessage(`No tienes suficientes acciones de ${symbol} para vender.`, 'error'); return false; }

            const sellPrice = stock.price;
            const avgPrice = portfolio[symbol].avgPrice;
            const revenue = sellPrice * quantity;
            cash += revenue;
            const soldQuantity = quantity;
            portfolio[symbol].quantity -= quantity;

            let transactionType = 'SELL';
            let messageType = 'success';
            if (isAutoSell) {
                transactionType = triggerType;
                messageType = triggerType === 'SL' ? 'error' : 'success';
            }

            addTransaction(transactionType, symbol, soldQuantity, sellPrice, avgPrice);

            if (portfolio[symbol].quantity === 0) { delete portfolio[symbol]; }

            if (isAutoSell) {
                if (triggerType === 'SL') showMessage(`¬°STOP-LOSS (${stopLossThreshold}%) ACTIVADO! Vendidas ${soldQuantity} acciones de ${symbol} a $${formatCurrency(sellPrice)}.`, messageType);
                else if (triggerType === 'TP') showMessage(`¬°TAKE-PROFIT (+${takeProfitThreshold}%) ACTIVADO! Vendidas ${soldQuantity} acciones de ${symbol} a $${formatCurrency(sellPrice)}.`, messageType);
                else showMessage(`¬°Venta Autom√°tica! Vendidas ${soldQuantity} acciones de ${symbol} a $${formatCurrency(sellPrice)}.`, 'info');
            } else {
                showMessage(`Vendiste ${soldQuantity} acciones de ${symbol} por $${formatCurrency(revenue)}`, messageType);
            }

            updateGameInfo();
            renderPortfolio();
            return true;
        }

        function addTransaction(type, symbol, quantity, price, avgPrice = null) {
            if (quantity > 0) {
                const transaction = { type: type, symbol: symbol, quantity: quantity, price: price, timestamp: new Date(), avgPrice: avgPrice };
                transactionHistory.push(transaction);
            } else {
                console.warn(`Intento de a√±adir transacci√≥n con cantidad 0 para ${symbol}`);
            }
        }

        function toggleStopLoss(symbol) {
            if (isPaused) {
                showMessage('El mercado est√° pausado. Reanuda para operar.', 'error');
                const cb = document.getElementById(`sl-toggle-${symbol}`);
                if(cb) cb.checked = !cb.checked;
                return;
            }
            if (portfolio[symbol]) {
                portfolio[symbol].slActive = !portfolio[symbol].slActive;
                showMessage(`Stop-Loss (${stopLossThreshold}%) para ${symbol} ${portfolio[symbol].slActive ? 'ACTIVADO' : 'DESACTIVADO'}.`, 'info');
            }
        }

        function toggleTakeProfit(symbol) {
             if (isPaused) {
                 showMessage('El mercado est√° pausado. Reanuda para operar.', 'error');
                 const cb = document.getElementById(`tp-toggle-${symbol}`);
                 if(cb) cb.checked = !cb.checked;
                 return;
             }
             if (portfolio[symbol]) {
                 portfolio[symbol].tpActive = !portfolio[symbol].tpActive;
                 showMessage(`Take-Profit (+${takeProfitThreshold}%) para ${symbol} ${portfolio[symbol].tpActive ? 'ACTIVADO' : 'DESACTIVADO'}.`, 'info');
             }
         }

        function checkAutoOrders() {
            const ordersToExecute = [];
            for (const symbol in portfolio) {
                const portfolioItem = portfolio[symbol];
                const stock = stocks.find(s => s.symbol === symbol);
                if (!stock || !portfolioItem || portfolioItem.quantity <= 0 || portfolioItem.avgPrice <= 0) continue;

                const currentPrice = stock.price;
                const avgPrice = portfolioItem.avgPrice;
                const gainLossPercent = ((currentPrice - avgPrice) / avgPrice) * 100;

                if (portfolioItem.slActive && gainLossPercent <= stopLossThreshold) {
                    ordersToExecute.push({ symbol: symbol, type: 'SL' });
                    continue;
                }
                if (portfolioItem.tpActive && gainLossPercent >= takeProfitThreshold) {
                    ordersToExecute.push({ symbol: symbol, type: 'TP' });
                }
            }
            ordersToExecute.forEach(order => {
                if (portfolio[order.symbol] && portfolio[order.symbol].quantity > 0) {
                    const quantityToSell = portfolio[order.symbol].quantity;
                    sellStock(order.symbol, quantityToSell, true, order.type);
                }
            });
        }

        const RSI_PERIOD = 14;

        function updateRSI(stock) {
            if (stock.history.length < RSI_PERIOD + 1) {
                stock.rsi = 50;
                return;
            }

            const last_two_prices = stock.history.slice(-2);
            const change = last_two_prices[1].price - last_two_prices[0].price;
            const gain = change > 0 ? change : 0;
            const loss = change < 0 ? -change : 0;

            stock.avgGain = ((stock.avgGain * (RSI_PERIOD - 1)) + gain) / RSI_PERIOD;
            stock.avgLoss = ((stock.avgLoss * (RSI_PERIOD - 1)) + loss) / RSI_PERIOD;

            if (stock.avgLoss === 0) {
                stock.rsi = 100;
            } else {
                const rs = stock.avgGain / stock.avgLoss;
                stock.rsi = 100 - (100 / (1 + rs));
            }

            stock.rsi_history.push({ tick: tickCounter, value: stock.rsi });
            if (stock.rsi_history.length > maxHistoryLength) {
                stock.rsi_history.shift();
            }
        }

        function manageRsiState(stock) {
            const RSI_OVERBOUGHT = 70;
            const RSI_OVERSOLD = 30;
            const REVERSAL_DURATION = 3; // El impulso del Rebote dura 3 ticks

            // Detectar Rebote Bajista (al salir de sobrecompra)
            if (stock.wasOverbought && stock.rsi < RSI_OVERBOUGHT) {
                stock.rsiReversalTicks = -REVERSAL_DURATION; // Negativo para bajista
                showMessage(`¬°Rebote bajista del RSI para ${stock.symbol}! Posible ca√≠da.`, 'error');
            }

            // Detectar Rebote Alcista (al salir de sobreventa)
            if (stock.wasOversold && stock.rsi > RSI_OVERSOLD) {
                stock.rsiReversalTicks = REVERSAL_DURATION; // Positivo para alcista
                showMessage(`¬°Rebote alcista del RSI para ${stock.symbol}! Posible subida.`, 'success');
            }

            // Actualizar el estado para el pr√≥ximo tick
            stock.wasOverbought = stock.rsi >= RSI_OVERBOUGHT;
            stock.wasOversold = stock.rsi <= RSI_OVERSOLD;
        }

        function simulatePriceChange() {
            const TREND_DURATION = 6; // Coincide con el valor usado en updateMovingAveragesAndTrends

            stocks.forEach(stock => {
                stock.lastPrice = stock.price;
                updateMovingAveragesAndTrends(stock);
                updateRSI(stock);
                manageRsiState(stock);

                let totalEffectiveTrend = stock.trend; // Tendencia base

                // 1. A√±adir fuerza de Eventos de Noticias
                activeEvents.forEach(activeEvent => {
                    if (activeEvent.event.target === 'ALL' || activeEvent.event.target === stock.symbol) {
                        totalEffectiveTrend += activeEvent.event.trend_modifier;
                    }
                });

                // 2. A√±adir fuerza del Cruce Dorado / de la Muerte (EFECTIVIDAD AUMENTADA)
                if (stock.trendState === 'bullish') {
                    totalEffectiveTrend += 0.0060; // Valor anterior: 0.0030
                } else if (stock.trendState === 'bearish') {
                    totalEffectiveTrend -= 0.0060; // Valor anterior: -0.0030
                }

                // 3. A√±adir fuerza del RSI (Rebote o Agotamiento) (EFECTIVIDAD AUMENTADA)
                if (stock.rsiReversalTicks > 0) { // Rebote Alcista activo
                    totalEffectiveTrend += 0.0044; // Impulso m√°s fuerte (Valor anterior: 0.0022)
                    stock.rsiReversalTicks--;
                } else if (stock.rsiReversalTicks < 0) { // Rebote Bajista activo
                    totalEffectiveTrend -= 0.0044; // Impulso m√°s fuerte (Valor anterior: -0.0022)
                    stock.rsiReversalTicks++;
                } else { // Si no hay rebote, comprobar agotamiento con m√°s fuerza
                    if (stock.rsi > 70) totalEffectiveTrend -= 0.0020; // Presi√≥n bajista m√°s fuerte (Valor anterior: -0.0005)
                    if (stock.rsi < 30) totalEffectiveTrend += 0.0020; // Presi√≥n alcista m√°s fuerte (Valor anterior: 0.0005)
                }

                let randomFactor = (Math.random() - 0.5) * 2;
                const isFirstTickOfTrend = stock.trendTicksRemaining === TREND_DURATION;

                // --- INICIO DE LA MODIFICACI√ìN ---
                // Se comprueba si es el primer tick justo despu√©s de un cruce.
                if (isFirstTickOfTrend) {
                    if (stock.trendState === 'bullish') {
                        // Para un Cruce Dorado, se fuerza un factor aleatorio 100% positivo.
                        // El valor estar√° entre 0.5 y 1.0.
                        randomFactor = Math.random() * 0.5 + 0.5;
                    } else if (stock.trendState === 'bearish') {
                        // Para un Cruce de la Muerte, se fuerza un factor aleatorio 100% negativo.
                        // El valor estar√° entre -1.0 y -0.5.
                        randomFactor = (Math.random() * 0.5 + 0.5) * -1;
                    }
                }
                // --- FIN DE LA MODIFICACI√ìN ---

                let priceChangePercent = randomFactor * stock.volatility + totalEffectiveTrend;

                const newPrice = stock.price * (1 + priceChangePercent);
                stock.price = Math.max(0.01, newPrice);

                stock.history.push({ tick: tickCounter, price: stock.price });
                if (stock.history.length > maxHistoryLength) {
                    stock.history.shift();
                }
            });
        }

        function manageEvents() {
             activeEvents = activeEvents.filter(activeEvent => {
                 activeEvent.remainingTicks--;
                 return activeEvent.remainingTicks > 0;
             });
             activeEvents.forEach(ae => { if(ae.isNew) ae.isNew = false; });
             if (activeEvents.length < MAX_ACTIVE_EVENTS && Math.random() < EVENT_PROBABILITY) {
                 const availableEvents = marketEvents.filter(event => !activeEvents.some(ae => ae.event.name === event.name));
                 if (availableEvents.length > 0) {
                     const newEvent = availableEvents[Math.floor(Math.random() * availableEvents.length)];
                     activeEvents.push({ event: newEvent, remainingTicks: newEvent.duration, isNew: true });
                     showEventNotification(`${newEvent.message}`);
                 }
             }
         }

        function updateMovingAveragesAndTrends(stock) {
            const STMA_PERIOD = 5;
            const LTMA_PERIOD = 15;
            const TREND_DURATION = 6;

            if (stock.history.length < LTMA_PERIOD) return;
            const was_above = stock.stma > stock.ltma;

            const stma_history_slice = stock.history.slice(-STMA_PERIOD);
            stock.stma = stma_history_slice.reduce((sum, h) => sum + h.price, 0) / stma_history_slice.length;
            const ltma_history_slice = stock.history.slice(-LTMA_PERIOD);
            stock.ltma = ltma_history_slice.reduce((sum, h) => sum + h.price, 0) / ltma_history_slice.length;

            stock.stmaHistory.push({ tick: tickCounter, value: stock.stma });
            if (stock.stmaHistory.length > maxHistoryLength) stock.stmaHistory.shift();
            stock.ltmaHistory.push({ tick: tickCounter, value: stock.ltma });
            if (stock.ltmaHistory.length > maxHistoryLength) stock.ltmaHistory.shift();

            const is_above = stock.stma > stock.ltma;

            if (stock.trendTicksRemaining > 0) {
                stock.trendTicksRemaining--;
                if (stock.trendTicksRemaining === 0) {
                    stock.trendState = 'neutral';
                }
            }

            if (stock.trendTicksRemaining === 0) {
                if (!was_above && is_above) {
                    stock.trendState = 'bullish';
                    stock.trendTicksRemaining = TREND_DURATION;
                    showMessage(`¬°Cruce Dorado detectado para ${stock.symbol}! Posible tendencia alcista.`, 'success');
                }
                else if (was_above && !is_above) {
                    stock.trendState = 'bearish';
                    stock.trendTicksRemaining = TREND_DURATION;
                    showMessage(`¬°Cruce de la Muerte detectado para ${stock.symbol}! Posible tendencia bajista.`, 'error');
                }
            }
        }

        function initializeChart() {
            const ctx = chartCanvas.getContext('2d');
            stockChart = new Chart(ctx, {
                type: 'line',
                data: { labels: [], datasets: [] },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    scales: {
                        y: { beginAtZero: false, ticks: { callback: value => '$' + formatCurrency(value) } },
                        x: { ticks: { display: false }, grid: { display: false } }
                    },
                    plugins: {
                        legend: { position: 'top' },
                        tooltip: {
                            mode: 'index', intersect: false,
                            callbacks: { label: context => `${context.dataset.label || ''}: $${formatCurrency(context.parsed.y)}` }
                        }
                    },
                    animation: { duration: 200 }
                }
            });
        }

        function initializeRsiChart() {
            const ctx = document.getElementById('rsiChart').getContext('2d');
            rsiChart = new Chart(ctx, {
                type: 'line',
                data: { labels: [], datasets: [] },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    scales: {
                        y: { min: 0, max: 100, ticks: { stepSize: 20 } },
                        x: { ticks: { display: false }, grid: { display: false } }
                    },
                    plugins: {
                        legend: { display: true, position: 'bottom', labels: { boxWidth: 12, font: { size: 10 } } },
                        tooltip: { mode: 'index', intersect: false },
                        annotation: {
                            annotations: {
                                line1: { type: 'line', yMin: 70, yMax: 70, borderColor: '#ef4444', borderWidth: 1, label: { content: 'Sobrecompra', enabled: true, position: 'start', backgroundColor: 'rgba(239, 68, 68, 0.2)' } },
                                line2: { type: 'line', yMin: 30, yMax: 30, borderColor: '#10b981', borderWidth: 1, label: { content: 'Sobreventa', enabled: true, position: 'start', backgroundColor: 'rgba(16, 185, 129, 0.2)' } }
                            }
                        }
                    },
                    animation: { duration: 200 }
                }
            });
        }

        function updateChart() {
             if (!stockChart) return;

             const visibleStocks = stocks.filter(stock => stock.showOnChart);
             let chartDatasets = [];
             let labels = [];

             let maxHistoryLengthFound = 0;
             visibleStocks.forEach(stock => {
                 if (stock.history && stock.history.length > maxHistoryLengthFound) {
                     maxHistoryLengthFound = stock.history.length;
                     labels = stock.history.map(h => h.tick);
                 }
             });
             if (labels.length === 0 && tickCounter >= 0) {
                 labels = Array.from({length: Math.min(tickCounter + 1, maxHistoryLength)}, (_, i) => Math.max(0, tickCounter - maxHistoryLength + 1) + i);
             }

             const stockForMA = visibleStocks[0];

             visibleStocks.forEach(stock => {
                const priceHistoryData = labels.map(tick => {
                     const historyPoint = stock.history?.find(h => h.tick === tick);
                     return historyPoint ? historyPoint.price : null;
                 });
                 chartDatasets.push({
                     label: stock.symbol,
                     data: priceHistoryData,
                     borderColor: stock.color,
                     backgroundColor: stock.color + '33',
                     borderWidth: 2,
                     tension: 0.1,
                     pointRadius: 0,
                     pointHoverRadius: 5
                 });

                 if (stock === stockForMA) {
                     const stmaHistoryData = labels.map(tick => {
                         const historyPoint = stock.stmaHistory?.find(h => h.tick === tick);
                         return historyPoint ? historyPoint.value : null;
                     });
                     chartDatasets.push({
                         label: `STMA (5) ${stock.symbol}`,
                         data: stmaHistoryData,
                         borderColor: '#06b6d4',
                         borderWidth: 1,
                         borderDash: [5, 5],
                         tension: 0.1,
                         pointRadius: 0
                     });

                     const ltmaHistoryData = labels.map(tick => {
                         const historyPoint = stock.ltmaHistory?.find(h => h.tick === tick);
                         return historyPoint ? historyPoint.value : null;
                     });
                     chartDatasets.push({
                         label: `LTMA (15) ${stock.symbol}`,
                         data: ltmaHistoryData,
                         borderColor: '#d946ef',
                         borderWidth: 1,
                         borderDash: [5, 5],
                         tension: 0.1,
                         pointRadius: 0
                     });
                 }
             });

             stockChart.data.labels = labels;
             stockChart.data.datasets = chartDatasets;
             stockChart.update();
         }

        function updateRsiChart() {
            if (!rsiChart) return;

            const visibleStocks = stocks.filter(stock => stock.showOnChart);
            if (visibleStocks.length === 0) {
                rsiChart.data.labels = [];
                rsiChart.data.datasets = [];
                rsiChart.update();
                return;
            }

            const labels = stockChart.data.labels;
            const stockForRSI = visibleStocks[0];

            const rsiHistoryData = labels.map(tick => {
                const historyPoint = stockForRSI.rsi_history?.find(h => h.tick === tick);
                return historyPoint ? historyPoint.value : null;
            });

            rsiChart.data.labels = labels;
            rsiChart.data.datasets = [{
                label: `RSI (14) ${stockForRSI.symbol}`,
                data: rsiHistoryData,
                borderColor: stockForRSI.color,
                borderWidth: 2,
                tension: 0.1,
                pointRadius: 0
            }];
            rsiChart.update();
        }

        function toggleChartVisibility(symbol) {
            const stock = stocks.find(s => s.symbol === symbol);
            if (stock) {
                stock.showOnChart = !stock.showOnChart;
                updateChart();
                updateRsiChart();
            }
        }

        function updateMarket() {
            if (isPaused) return;
            tickCounter++;

            manageEvents();
            simulatePriceChange();

            renderStockMarket();
            renderPortfolio();
            checkAutoOrders();
            updateChart();
            updateRsiChart();
            saveGameState();
        }

        function setPauseState(shouldPause) {
             isPaused = shouldPause;
             if (isPaused) {
                 if (gameInterval) { clearInterval(gameInterval); gameInterval = null; }
                 pauseResumeBtn.textContent = 'Reanudar';
                 pauseResumeBtn.classList.remove('pause-button');
                 pauseResumeBtn.classList.add('resume-button');
                 showMessage('Mercado pausado. Haz clic en Reanudar para continuar.', 'info');
             } else {
                 if (!gameInterval) {
                     updateMarket();
                     gameInterval = setInterval(updateMarket, updateInterval);
                 }
                 pauseResumeBtn.textContent = 'Pausar';
                 pauseResumeBtn.classList.remove('resume-button');
                 pauseResumeBtn.classList.add('pause-button');
                 showMessage(`Mercado reanudado. Velocidad: ${updateInterval/1000}s por tick.`, 'info');
             }
         }

        function togglePause() {
            setPauseState(!isPaused);
        }

        function showHistory() {
             historyListEl.innerHTML = '';
             if (transactionHistory.length === 0) {
                 historyListEl.innerHTML = '<li class="text-gray-500">No hay transacciones todav√≠a en esta sesi√≥n.</li>';
             } else {
                 [...transactionHistory].sort((a, b) => b.timestamp - a.timestamp).forEach(tx => {
                     const li = document.createElement('li');
                     li.className = 'history-list-item';
                     const timestamp = (tx.timestamp instanceof Date) ? tx.timestamp : new Date(tx.timestamp);
                     const stockInfo = stocks.find(s => s.symbol === tx.symbol);
                     const stockName = stockInfo ? stockInfo.name : tx.symbol;

                     let gainLossHTML = '';
                     if (['SELL', 'SL', 'TP'].includes(tx.type) && tx.avgPrice !== null && tx.avgPrice > 0) {
                         const realizedGainLoss = (tx.price - tx.avgPrice) * tx.quantity;
                         const gainLossClass = realizedGainLoss >= 0 ? 'price-up' : 'price-down';
                         gainLossHTML = `<div class="history-gain-loss ${gainLossClass}">Ganancia/P√©rdida: $${formatCurrency(realizedGainLoss)}</div>`;
                     }

                     li.innerHTML = `
                         <div class="history-main-line">
                             <span class="history-type-${tx.type}">${tx.type}</span>
                             <span>${stockName}:</span>
                             <span>${tx.quantity} acc.</span>
                             <span>@ $${formatCurrency(tx.price)}</span>
                             <span class="text-gray-500 text-xs float-right">${formatTimestamp(timestamp)}</span>
                         </div>
                         ${gainLossHTML}`;
                     historyListEl.appendChild(li);
                 });
             }
             historyModal.classList.remove('hidden');
         }

        function closeHistory() { historyModal.classList.add('hidden'); }

        function getCurrentGlobalBalance() {
            try {
                const savedBalance = localStorage.getItem(BALANCE_LOCAL_STORAGE_KEY);
                if (savedBalance !== null) { const parsedBalance = parseInt(savedBalance); if (!isNaN(parsedBalance)) { return parsedBalance; } }
            } catch (error) { console.error("Error al leer el saldo global desde localStorage:", error); }
            return DEFAULT_BALANCE;
        }

        function saveGlobalBalance(newBalance) {
             try {
                 const balanceToSave = Math.round(newBalance);
                 if (isNaN(balanceToSave)) { console.error("Intento de guardar un saldo global inv√°lido (NaN)."); return; }
                 localStorage.setItem(BALANCE_LOCAL_STORAGE_KEY, balanceToSave.toString());
             } catch (error) { console.error("Error al guardar el saldo global en localStorage:", error); }
         }

        function saveGameState() {
            try {
                const gameState = {
                    cash: cash,
                    stocks: stocks.map(s => ({
                        symbol: s.symbol, name: s.name, price: s.price, lastPrice: s.lastPrice,
                        volatility: s.volatility, trend: s.trend, color: s.color,
                        showOnChart: s.showOnChart, history: s.history,
                        stma: s.stma, ltma: s.ltma,
                        trendState: s.trendState, trendTicksRemaining: s.trendTicksRemaining,
                        stmaHistory: s.stmaHistory, ltmaHistory: s.ltmaHistory,
                        rsi: s.rsi, avgGain: s.avgGain, avgLoss: s.avgLoss, rsi_history: s.rsi_history,
                        rsiReversalTicks: s.rsiReversalTicks, wasOverbought: s.wasOverbought, wasOversold: s.wasOversold
                    })),
                    portfolio: portfolio,
                    tickCounter: tickCounter,
                    activeEvents: activeEvents
                };
                sessionStorage.setItem(STOCK_GAME_STATE_KEY, JSON.stringify(gameState));
            } catch (error) {
                console.error("Error al guardar el estado del juego:", error);
            }
        }

        // MODIFICADO: Esta funci√≥n ahora siempre inicia una nueva partida.
        function startNewGame() {
            console.log("Iniciando nueva partida desde cero.");

            try {
                 const initialInvestmentStr = sessionStorage.getItem(GAME6_INVESTMENT_SESSION_KEY);
                 let parsedInvestment = 10000;
                 if (initialInvestmentStr) {
                     const tempInvestment = parseInt(initialInvestmentStr);
                     if (!isNaN(tempInvestment) && tempInvestment > 0) { parsedInvestment = tempInvestment; }
                 }
                 initialInvestment = parsedInvestment;
            } catch(e) {
                 initialInvestment = 10000;
                 console.error("Error leyendo la inversi√≥n inicial, se usar√° el valor por defecto.");
            }

            cash = initialInvestment;
            // Se usa structuredClone para una copia profunda y evitar referencias cruzadas
            stocks = structuredClone(initialStockData).map(initialStock => ({
                ...initialStock,
                lastPrice: initialStock.price,
                history: [{ tick: -1, price: initialStock.price }] // Empezamos con un punto base
            }));
            portfolio = {};
            transactionHistory = [];
            tickCounter = -1; // Se inicia en -1 para que el primer tick de la simulaci√≥n sea 0
            activeEvents = [];
            isPaused = true;
        }

        // MODIFICADO: La funci√≥n principal de inicializaci√≥n.
        function initializeGame() {
            // 1. Iniciar una partida nueva siempre.
            startNewGame();

            // 2. Ejecutar una simulaci√≥n silenciosa de 100 ticks.
            console.log("Ejecutando simulaci√≥n inicial de 100 ticks...");
            showMessage("Generando historial del mercado...", "info");
            for (let i = 0; i < 100; i++) {
                tickCounter++;
                // No se gestionan eventos en la simulaci√≥n inicial para no abrumar con mensajes
                // manageEvents();
                simulatePriceChange();
            }
            console.log("Simulaci√≥n inicial completada.");

            // 3. Preparar y renderizar la interfaz con los datos ya simulados.
            initializeChart();
            initializeRsiChart();
            buildStockMarketList();
            renderPortfolio();
            updateGameInfo();
            updateChart();
            updateRsiChart();

            // 4. Dejar el juego pausado por defecto.
            setPauseState(true);
            showMessage("¬°Bienvenido! El mercado est√° listo y pausado. Analiza los gr√°ficos y opera cuando quieras.", "success");
        }

        function handleExitClick(event) {
            event.preventDefault();
            if (!isPaused) { setPauseState(true); }
            saveGameState();
            try {
                const finalPortfolioValue = calculatePortfolioValue();
                const finalTotalValue = cash + finalPortfolioValue;
                const netGainLoss = finalTotalValue - initialInvestment;
                const currentGlobalBalance = getCurrentGlobalBalance();
                const newGlobalBalance = currentGlobalBalance + netGainLoss;
                saveGlobalBalance(newGlobalBalance);
            } catch (error) {
                console.error("Error durante el proceso de actualizaci√≥n del saldo global al salir:", error);
            }
            window.location.href = event.target.href;
        }

        pauseResumeBtn.addEventListener('click', togglePause);
        historyModal.addEventListener('click', (event) => { if (event.target === historyModal) { closeHistory(); } });
        exitButton.addEventListener('click', handleExitClick);

        window.onload = initializeGame;

    </script>
</body>
</html>
